#!/bin/bash
# Janus Forge Cycle Pre-commit Hook
# Validates version consistency and Forge Cycle integrity

set -e

echo "üîç Janus Forge Cycle: Pre-commit validation..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Check if VERSION file exists and is valid
if [ ! -f "VERSION" ]; then
    print_status $RED "‚ùå VERSION file not found"
    echo "Run the Versioner agent to initialize versioning"
    exit 1
fi

VERSION=$(cat VERSION)
print_status $GREEN "‚úÖ VERSION file found: $VERSION"

# Validate version format (MAJOR.MINOR.PATCH-PKGREL, Linux kernel style)
if ! echo "$VERSION" | grep -qE '^([0-9]+)\.([0-9]+)\.([0-9]+)-([0-9]+)$'; then
    print_status $RED "‚ùå Invalid version format: $VERSION"
    echo "Expected format: MAJOR.MINOR.PATCH-PKGREL"
    echo "Examples: 0.2.0-1, 0.2.0-2, 1.0.0-1"
    exit 1
fi

print_status $GREEN "‚úÖ Version format valid: $VERSION"

# Check if this is a dirty build (uncommitted changes)
if ! git diff --quiet || ! git diff --staged --quiet; then
    print_status $YELLOW "‚ö†Ô∏è  Repository has uncommitted changes"

    # For dev builds, ensure version reflects dirty state
    if [[ "$VERSION" == *"-dev"* ]] && [[ ! "$VERSION" == *"+dirty" ]]; then
        print_status $YELLOW "‚ö†Ô∏è  Dev build should be marked as dirty"
        echo "Consider running: ./janus version bump dev"
    fi
else
    print_status $GREEN "‚úÖ Clean working directory"
fi

# Validate that version is consistent with branch type
BRANCH=$(git branch --show-current)

if [[ "$BRANCH" == "main" ]] || [[ "$BRANCH" == release* ]]; then
    # Stable branch: should not have -dev suffix
    if [[ "$VERSION" == *"-dev"* ]]; then
        print_status $RED "‚ùå Stable branch should not have -dev version"
        echo "Convert to release version: ./janus version bump release"
        exit 1
    fi
    print_status $GREEN "‚úÖ Stable branch version format correct"
else
    # Unstable branch: should have -dev suffix and Git metadata
    if [[ ! "$VERSION" == *"-dev"* ]]; then
        print_status $YELLOW "‚ö†Ô∏è  Unstable branch should have -dev version"
        echo "Consider running: ./janus version bump dev"
    fi

    if [[ ! "$VERSION" == *"+"* ]]; then
        print_status $YELLOW "‚ö†Ô∏è  Unstable branch should have Git hash metadata"
        echo "Consider running: ./janus version bump dev"
    fi
fi

# Check for VERSION file in commit
if git diff --cached --name-only | grep -q "^VERSION$"; then
    print_status $YELLOW "‚ÑπÔ∏è  VERSION file will be committed"

    # Validate that VERSION changes are atomic and follow SemVer
    VERSION_DIFF=$(git diff --cached VERSION | grep '^[+-]' | head -10)

    if echo "$VERSION_DIFF" | grep -q '^[+-][0-9]\+\.[0-9]\+\.[0-9]\+'; then
        print_status $GREEN "‚úÖ VERSION change follows SemVer format"
    else
        print_status $YELLOW "‚ö†Ô∏è  VERSION change detected but format unclear"
    fi
else
    print_status $GREEN "‚úÖ No VERSION file changes in commit"
fi

# Check for .codex/specs files in commit (Forge Cycle artifacts)
SPEC_FILES=$(git diff --cached --name-only | grep "^\.codex/specs/" | wc -l)

if [ "$SPEC_FILES" -gt 0 ]; then
    print_status $GREEN "‚úÖ Forge Cycle artifacts detected ($SPEC_FILES files)"

    # Validate that spec files have corresponding version bump
    if git diff --cached --name-only | grep -q "^\.codex/specs/.*\.md$"; then
        print_status $YELLOW "‚ÑπÔ∏è  Spec files modified - ensure version bump matches"
    fi
else
    print_status $GREEN "‚úÖ No spec file changes"
fi

# ==============================================================================
# Migrated Checks from .pre-commit-config.yaml
# ==============================================================================

# 1. Block Forbidden Paths
# checks for .kiro, .zig-cache, zig-out, test_golden_snapshots
# We use git diff --cached --name-only to check staged files instead of scanning all files
FORBIDDEN_FILES=$(git diff --cached --name-only | grep -E "(\.kiro/|\.zig-cache/|\.zig-global-cache/|zig-out/|test_golden_snapshots/)" || true)

if [ ! -z "$FORBIDDEN_FILES" ]; then
    print_status $RED "‚ùå Forbidden paths detected in commit:"
    echo "$FORBIDDEN_FILES"
    echo "Please unstage these files or add them to .gitignore."
    exit 1
fi
print_status $GREEN "‚úÖ No forbidden paths detected"

# 2. Check Front Matter (Markdown)
# TODO: Re-enable strict front-matter check after Documentation Standarization task (v0.3.0)
# if [ -f "tools/check_front_matter.sh" ]; then
#     # Pass staged markdown files to the script
#     # Exclude third_party, vscode-extension, teaching, tests, and tools from strict front-matter checks
#     STAGED_MD=$(git diff --cached --name-only | grep "\.md$" | grep -vE "^(third_party|vscode-extension|teaching|tests|tools)/" || true)
#     if [ ! -z "$STAGED_MD" ]; then
#         if ! bash tools/check_front_matter.sh $STAGED_MD; then
#             print_status $RED "‚ùå Front matter check failed"
#             exit 1
#         fi
#         print_status $GREEN "‚úÖ Front matter check passed"
#     fi
# else
#     print_status $YELLOW "‚ö†Ô∏è  tools/check_front_matter.sh not found, skipping check"
# fi

print_status $GREEN "üéØ Pre-commit validation passed!"
echo ""
echo "üìã Commit Summary:"
echo "  Version: $VERSION"
echo "  Branch: $BRANCH"
echo "  Status: $(if [ -z "$(git status --porcelain)" ]; then echo "Clean"; else echo "Dirty"; fi)"
echo ""

exit 0