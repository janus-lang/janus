# golden test: max subset XOR on classic set
func build_basis(xs: Array[u64]) -> Array[u64] do
  var basis := array.make[u64]()
  for x0 in xs do
    var x := x0
    for b in basis { x = min(x, x ^ b) }
    if x != 0u64 do
      basis.push x
      basis.sort_desc_by_msb()
    end
  end
  return basis
end
func basis_max_xor(basis: Array[u64]) -> u64 do
  var best := 0u64
  for b in basis { best = max(best, best ^ b) }
  return best
end
let xs := [3u64, 10, 5, 25, 2, 8]
let b  := build_basis(xs)
print basis_max_xor(b)
# EXPECT: 28


// Your golden harness can assert “stdout.trim == EXPECT” and fail on mismatch.
// Optional: track allocations to prove iter.reduce chains are allocation-free.
