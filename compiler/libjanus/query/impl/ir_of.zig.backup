// SPDX-License-Identifier: LCL-1.0
// Copyright (c) 2026 Self Sovereign Society Foundation

//! Q.IROf Implementation
//! Task 2.6 - Lower to IR, store ResultBytes in CAS; return IRCID + deps
//!
//! This query lowers Janus AST to intermediate representation (IR) and stores
//! the result in content-addressed storage (CAS) for maximum reuse and
//! deterministic builds.

const std = @import("std");
const Allocator = std.mem.Allocator;
const Blake3 = std.crypto.hash.Blake3;
const context = @import("../context.zig");
const astdb = @import("../../astdb.zig");

const QueryCtx = context.QueryCtx;
const CanonicalArgs = context.CanonicalArgs;
const QueryResultData = context.QueryResultData;
const IRInfo = context.IRInfo;
const CID = @import("../../astdb/ids.zig").CID;

/// Generate IR for a function or module and store in CAS
pub fn irOf(query_ctx: *QueryCtx, args: CanonicalArgs) !QueryResultData {
    // Extract arguments
    if (args.items.len != 2) {
        return error.QE0005_NonCanonicalArg;
    }

    const target_cid = switch (args.items[0]) {
        .cid => |cid| cid,
        else => return error.QE0005_NonCanonicalArg,
    };

    const codegen_knobs = switch (args.items[1]) {
        .cid => |cid| cid, // CID of codegen configuration
        else => return error.QE0005_NonCanonicalArg,
    };

    // Record dependencies
    try query_ctx.dependency_tracker.addDependency(.{ .cid = target_cid });
    try query_ctx.dependency_tracker.addDependency(.{ .cid = codegen_knobs });

    // Get the target node
    const target_node = try query_ctx.astdb.getNode(target_cid);

    // Generate IR based on target type
    const ir_result = try generateIR(query_ctx, target_node, codegen_knobs);

    // Store IR in CAS and get content-addressed ID
    const ir_cid = try storeInCAS(query_ctx, ir_result.ir_bytes);

    return QueryResultData{
        .ir_info = IRInfo{
            .ir_cid = ir_cid,
            .dependencies = ir_result.dependencies,
            .optimization_level = ir_result.optimization_level,
        },
    };
}

/// IR generation result before CAS storage
const IRGenerationResult = struct {
    ir_bytes: []const u8,
    dependencies: []CID,
    optimization_level: u8,
    metadata: IRMetadata,
};

/// Metadata about generated IR
const IRMetadata = struct {
    target_type: TargetType,
    function_count: u32,
    instruction_count: u32,
    register_count: u32,
    memory_usage: u64,
    generation_time_ms: u64,

    const TargetType = enum {
        function,
        module,
        expression,
        type_definition,
    };
};

/// Generate IR for a target node
fn generateIR(query_ctx: *QueryCtx, target_node: astdb.AstNode, codegen_knobs_cid: CID) !IRGenerationResult {
    const start_time = std.time.milliTimestamp();

    // Get codegen configuration
    const codegen_config = try getCodegenConfig(query_ctx, codegen_knobs_cid);

    // Generate IR based on node type
    const ir_result = switch (target_node.node_type) {
        .function_declaration => try generateFunctionIR(query_ctx, target_node, codegen_config),
        .module => try generateModuleIR(query_ctx, target_node, codegen_config),
        .type_annotation => try generateTypeIR(query_ctx, target_node, codegen_config),
        else => try generateExpressionIR(query_ctx, target_node, codegen_config),
    };

    const end_time = std.time.milliTimestamp();
    const generation_time = @intCast(u64, end_time - start_time);

    return IRGenerationResult{
        .ir_bytes = ir_result.ir_bytes,
        .dependencies = ir_result.dependencies,
        .optimization_level = codegen_config.optimization_level,
        .metadata = IRMetadata{
            .target_type = ir_result.target_type,
            .function_count = ir_result.function_count,
            .instruction_count = ir_result.instruction_count,
            .register_count = ir_result.register_count,
            .memory_usage = ir_result.memory_usage,
            .generation_time_ms = generation_time,
        },
    };
}

/// Codegen configuration
const CodegenConfig = struct {
    optimization_level: u8,
    target_arch: TargetArch,
    debug_info: bool,
    inline_threshold: u32,
    vectorization: bool,
    bounds_checking: bool,
    effect_tracking: bool,

    const TargetArch = enum {
        x86_64,
        aarch64,
        wasm32,
        riscv64,
    };
};

/// IR generation result for specific node types
const NodeIRResult = struct {
    ir_bytes: []const u8,
    dependencies: []CID,
    target_type: IRMetadata.TargetType,
    function_count: u32,
    instruction_count: u32,
    register_count: u32,
    memory_usage: u64,
};

/// Generate IR for a function declaration
fn generateFunctionIR(query_ctx: *QueryCtx, function_node: astdb.AstNode, config: CodegenConfig) !NodeIRResult {
    var ir_builder = IRBuilder.init(query_ctx.allocator, config);
    defer ir_builder.deinit();

    var dependencies: std.ArrayList(CID) = .empty;

    // Generate function prologue
    try ir_builder.emitFunctionPrologue(function_node.function_name);

    // Process parameters
    for (function_node.parameters) |param_cid| {
        const param_node = try query_ctx.astdb.getNode(param_cid);
        try ir_builder.emitParameter(param_node.parameter_name, param_node.parameter_type);
        try dependencies.append(param_cid);
    }

    // Generate function body
    if (function_node.body) |body_cid| {
        const body_ir = try generateBlockIR(query_ctx, body_cid, &ir_builder, &dependencies);
        try ir_builder.emitBlock(body_ir);
    }

    // Generate function epilogue
    try ir_builder.emitFunctionEpilogue();

    // Apply optimizations
    if (config.optimization_level > 0) {
        try ir_builder.optimize();
    }

    return NodeIRResult{
        .ir_bytes = ir_builder.getBytes(),
        .dependencies = dependencies.toOwnedSlice(),
        .target_type = .function,
        .function_count = 1,
        .instruction_count = ir_builder.getInstructionCount(),
        .register_count = ir_builder.getRegisterCount(),
        .memory_usage = ir_builder.getMemoryUsage(),
    };
}

/// Generate IR for a module
fn generateModuleIR(query_ctx: *QueryCtx, module_node: astdb.AstNode, config: CodegenConfig) !NodeIRResult {
    var ir_builder = IRBuilder.init(query_ctx.allocator, config);
    defer ir_builder.deinit();

    var dependencies: std.ArrayList(CID) = .empty;
    var function_count: u32 = 0;

    // Generate module prologue
    try ir_builder.emitModulePrologue(module_node.module_name);

    // Process all top-level declarations
    for (module_node.children) |child_cid| {
        const child_node = try query_ctx.astdb.getNode(child_cid);
        try dependencies.append(child_cid);

        switch (child_node.node_type) {
            .function_declaration => {
                const func_ir = try generateFunctionIR(query_ctx, child_node, config);
                try ir_builder.emitFunction(func_ir.ir_bytes);
                function_count += 1;
            },
            .type_annotation => {
                const type_ir = try generateTypeIR(query_ctx, child_node, config);
                try ir_builder.emitType(type_ir.ir_bytes);
            },
            .variable_declaration => {
                const var_ir = try generateVariableIR(query_ctx, child_node, config);
                try ir_builder.emitGlobalVariable(var_ir.ir_bytes);
            },
            else => {
                // Skip other node types for now
            },
        }
    }

    // Generate module epilogue
    try ir_builder.emitModuleEpilogue();

    return NodeIRResult{
        .ir_bytes = ir_builder.getBytes(),
        .dependencies = dependencies.toOwnedSlice(),
        .target_type = .module,
        .function_count = function_count,
        .instruction_count = ir_builder.getInstructionCount(),
        .register_count = ir_builder.getRegisterCount(),
        .memory_usage = ir_builder.getMemoryUsage(),
    };
}

/// Generate IR for a type definition
fn generateTypeIR(query_ctx: *QueryCtx, type_node: astdb.AstNode, config: CodegenConfig) !NodeIRResult {
    var ir_builder = IRBuilder.init(query_ctx.allocator, config);
    defer ir_builder.deinit();

    var dependencies: std.ArrayList(CID) = .empty;

    // Generate type definition IR
    try ir_builder.emitTypeDefinition(type_node.type_name);

    // Process type fields if it's a struct/class
    if (type_node.type_cid) |type_def_cid| {
        const type_def = try query_ctx.astdb.getTypeDefinition(type_def_cid);
        try dependencies.append(type_def_cid);

        for (type_def.fields) |field| {
            try ir_builder.emitField(field.name, field.field_type.type_name);
            try dependencies.append(field.definition_cid);
        }

        for (type_def.methods) |method| {
            try ir_builder.emitMethod(method.name);
            try dependencies.append(method.definition_cid);
        }
    }

    return NodeIRResult{
        .ir_bytes = ir_builder.getBytes(),
        .dependencies = dependencies.toOwnedSlice(),
        .target_type = .type_definition,
        .function_count = 0,
        .instruction_count = ir_builder.getInstructionCount(),
        .register_count = ir_builder.getRegisterCount(),
        .memory_usage = ir_builder.getMemoryUsage(),
    };
}

/// Generate IR for an expression
fn generateExpressionIR(query_ctx: *QueryCtx, expr_node: astdb.AstNode, config: CodegenConfig) !NodeIRResult {
    var ir_builder = IRBuilder.init(query_ctx.allocator, config);
    defer ir_builder.deinit();

    var dependencies: std.ArrayList(CID) = .empty;

    // Generate expression IR based on node type
    switch (expr_node.node_type) {
        .literal_integer => {
            try ir_builder.emitIntegerLiteral(expr_node.token_text);
        },
        .literal_float => {
            try ir_builder.emitFloatLiteral(expr_node.token_text);
        },
        .literal_string => {
            try ir_builder.emitStringLiteral(expr_node.token_text);
        },
        .literal_boolean => {
            try ir_builder.emitBooleanLiteral(expr_node.token_text);
        },
        .identifier => {
            try ir_builder.emitVariableLoad(expr_node.token_text);
        },
        .binary_operation => {
            const left_ir = try generateExpressionIR(query_ctx, try query_ctx.astdb.getNode(expr_node.children[0]), config);
            const right_ir = try generateExpressionIR(query_ctx, try query_ctx.astdb.getNode(expr_node.children[1]), config);

            try ir_builder.emitBinaryOperation(expr_node.operator_type, left_ir.ir_bytes, right_ir.ir_bytes);

            // Add dependencies from sub-expressions
            for (left_ir.dependencies) |dep| try dependencies.append(dep);
            for (right_ir.dependencies) |dep| try dependencies.append(dep);
        },
        .function_call => {
            // Use Q.Dispatch to resolve the function
            const dispatch = @import("dispatch.zig");
            var dispatch_args = CanonicalArgs.init(query_ctx.allocator);
            defer dispatch_args.deinit();

            try dispatch_args.append(.{ .string = expr_node.function_name });
            try dispatch_args.append(.{ .cid = expr_node.arguments_cid });
            try dispatch_args.append(.{ .cid = expr_node.cid });

            const dispatch_result = try dispatch.dispatch(query_ctx, dispatch_args);
            const selected_function_cid = dispatch_result.dispatch_info.function_cid;

            try ir_builder.emitFunctionCall(expr_node.function_name, selected_function_cid);
            try dependencies.append(selected_function_cid);

            // Generate argument IR
            for (expr_node.arguments) |arg_cid| {
                const arg_ir = try generateExpressionIR(query_ctx, try query_ctx.astdb.getNode(arg_cid), config);
                try ir_builder.emitArgument(arg_ir.ir_bytes);

                for (arg_ir.dependencies) |dep| try dependencies.append(dep);
            }
        },
        else => {
            return error.UnsupportedExpressionType;
        },
    }

    return NodeIRResult{
        .ir_bytes = ir_builder.getBytes(),
        .dependencies = dependencies.toOwnedSlice(),
        .target_type = .expression,
        .function_count = 0,
        .instruction_count = ir_builder.getInstructionCount(),
        .register_count = ir_builder.getRegisterCount(),
        .memory_usage = ir_builder.getMemoryUsage(),
    };
}

/// Generate IR for a block statement
fn generateBlockIR(query_ctx: *QueryCtx, block_cid: CID, ir_builder: *IRBuilder, dependencies: *std.ArrayList(CID)) ![]const u8 {
    const block_node = try query_ctx.astdb.getNode(block_cid);
    try dependencies.append(block_cid);

    try ir_builder.emitBlockStart();

    for (block_node.statements) |stmt_cid| {
        const stmt_node = try query_ctx.astdb.getNode(stmt_cid);
        try dependencies.append(stmt_cid);

        switch (stmt_node.node_type) {
            .variable_declaration => {
                const var_ir = try generateVariableIR(query_ctx, stmt_node, ir_builder.config);
                try ir_builder.emitLocalVariable(var_ir.ir_bytes);
            },
            .variable_assignment => {
                const assign_ir = try generateAssignmentIR(query_ctx, stmt_node, ir_builder.config);
                try ir_builder.emitAssignment(assign_ir.ir_bytes);
            },
            .return_statement => {
                if (stmt_node.return_value) |return_cid| {
                    const return_ir = try generateExpressionIR(query_ctx, try query_ctx.astdb.getNode(return_cid), ir_builder.config);
                    try ir_builder.emitReturn(return_ir.ir_bytes);
                } else {
                    try ir_builder.emitReturnVoid();
                }
            },
            else => {
                // Generate expression IR for other statement types
                const expr_ir = try generateExpressionIR(query_ctx, stmt_node, ir_builder.config);
                try ir_builder.emitExpression(expr_ir.ir_bytes);
            },
        }
    }

    try ir_builder.emitBlockEnd();
    return ir_builder.getBlockBytes();
}

/// Generate IR for variable declaration
fn generateVariableIR(query_ctx: *QueryCtx, var_node: astdb.AstNode, config: CodegenConfig) !NodeIRResult {
    var ir_builder = IRBuilder.init(query_ctx.allocator, config);
    defer ir_builder.deinit();

    var dependencies: std.ArrayList(CID) = .empty;

    // Get variable type
    const type_of = @import("type_of.zig");
    var type_args = CanonicalArgs.init(query_ctx.allocator);
    defer type_args.deinit();

    try type_args.append(.{ .cid = var_node.cid });
    const type_result = try type_of.typeOf(query_ctx, type_args);

    // Emit variable declaration
    try ir_builder.emitVariableDeclaration(
        var_node.variable_name,
        type_result.type_info.type_name,
        var_node.is_mutable,
    );

    // Generate initializer if present
    if (var_node.initializer) |init_cid| {
        const init_ir = try generateExpressionIR(query_ctx, try query_ctx.astdb.getNode(init_cid), config);
        try ir_builder.emitInitializer(init_ir.ir_bytes);

        for (init_ir.dependencies) |dep| try dependencies.append(dep);
    }

    return NodeIRResult{
        .ir_bytes = ir_builder.getBytes(),
        .dependencies = dependencies.toOwnedSlice(),
        .target_type = .expression,
        .function_count = 0,
        .instruction_count = ir_builder.getInstructionCount(),
        .register_count = ir_builder.getRegisterCount(),
        .memory_usage = ir_builder.getMemoryUsage(),
    };
}

/// Generate IR for assignment
fn generateAssignmentIR(query_ctx: *QueryCtx, assign_node: astdb.AstNode, config: CodegenConfig) !NodeIRResult {
    var ir_builder = IRBuilder.init(query_ctx.allocator, config);
    defer ir_builder.deinit();

    var dependencies: std.ArrayList(CID) = .empty;

    // Generate value IR
    if (assign_node.assigned_value) |value_cid| {
        const value_ir = try generateExpressionIR(query_ctx, try query_ctx.astdb.getNode(value_cid), config);
        try ir_builder.emitStore(assign_node.variable_name, value_ir.ir_bytes);

        for (value_ir.dependencies) |dep| try dependencies.append(dep);
    }

    return NodeIRResult{
        .ir_bytes = ir_builder.getBytes(),
        .dependencies = dependencies.toOwnedSlice(),
        .target_type = .expression,
        .function_count = 0,
        .instruction_count = ir_builder.getInstructionCount(),
        .register_count = ir_builder.getRegisterCount(),
        .memory_usage = ir_builder.getMemoryUsage(),
    };
}

/// Get codegen configuration from CID
fn getCodegenConfig(query_ctx: *QueryCtx, config_cid: CID) !CodegenConfig {
    // For now, return default configuration
    // In a full implementation, this would deserialize from the CID
    _ = query_ctx;
    _ = config_cid;

    return CodegenConfig{
        .optimization_level = 2,
        .target_arch = .x86_64,
        .debug_info = true,
        .inline_threshold = 100,
        .vectorization = true,
        .bounds_checking = true,
        .effect_tracking = true,
    };
}

/// Store IR bytes in content-addressed storage
fn storeInCAS(query_ctx: *QueryCtx, ir_bytes: []const u8) !CID {
    // Compute content hash
    var hasher = Blake3.init(.{});
    hasher.update(ir_bytes);
    const content_hash = hasher.final();

    // Create CID from content hash
    const ir_cid = CID{ .bytes = content_hash };

    // Store in CAS (this would be implemented by the CAS system)
    // For now, we just return the CID
    _ = query_ctx;

    return ir_cid;
}

/// IR Builder for generating intermediate representation
const IRBuilder = struct {
    allocator: Allocator,
    config: CodegenConfig,
    instructions: std.ArrayList(IRInstruction),
    registers: std.ArrayList(IRRegister),
    memory_usage: u64,

    const Self = @This();

    pub fn init(allocator: Allocator, config: CodegenConfig) IRBuilder {
        return IRBuilder{
            .allocator = allocator,
            .config = config,
            .instructions = std.ArrayList(IRInstruction).init(allocator),
            .registers = std.ArrayList(IRRegister).init(allocator),
            .memory_usage = 0,
        };
    }

    pub fn deinit(self: *Self) void {
        self.instructions.deinit();
        self.registers.deinit();
    }

    pub fn emitFunctionPrologue(self: *Self, name: []const u8) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .function_start,
            .operands = &[_]IROperand{IROperand{ .string = name }},
        });
    }

    pub fn emitFunctionEpilogue(self: *Self) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .function_end,
            .operands = &[_]IROperand{},
        });
    }

    pub fn emitParameter(self: *Self, name: []const u8, param_type: []const u8) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .parameter,
            .operands = &[_]IROperand{
                IROperand{ .string = name },
                IROperand{ .string = param_type },
            },
        });
    }

    pub fn emitIntegerLiteral(self: *Self, value: []const u8) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .load_immediate_int,
            .operands = &[_]IROperand{IROperand{ .string = value }},
        });
    }

    pub fn emitFloatLiteral(self: *Self, value: []const u8) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .load_immediate_float,
            .operands = &[_]IROperand{IROperand{ .string = value }},
        });
    }

    pub fn emitStringLiteral(self: *Self, value: []const u8) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .load_immediate_string,
            .operands = &[_]IROperand{IROperand{ .string = value }},
        });
    }

    pub fn emitBooleanLiteral(self: *Self, value: []const u8) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .load_immediate_bool,
            .operands = &[_]IROperand{IROperand{ .string = value }},
        });
    }

    pub fn emitVariableLoad(self: *Self, name: []const u8) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .load_variable,
            .operands = &[_]IROperand{IROperand{ .string = name }},
        });
    }

    pub fn emitBinaryOperation(self: *Self, op_type: astdb.AstNode.OperatorType, left: []const u8, right: []const u8) !void {
        const opcode = switch (op_type) {
            .add => IROpcode.add,
            .subtract => IROpcode.subtract,
            .multiply => IROpcode.multiply,
            .divide => IROpcode.divide,
            .equal => IROpcode.compare_equal,
            .not_equal => IROpcode.compare_not_equal,
            .less_than => IROpcode.compare_less,
            .greater_than => IROpcode.compare_greater,
            else => IROpcode.nop,
        };

        try self.instructions.append(IRInstruction{
            .opcode = opcode,
            .operands = &[_]IROperand{
                IROperand{ .bytes = left },
                IROperand{ .bytes = right },
            },
        });
    }

    pub fn emitFunctionCall(self: *Self, name: []const u8, function_cid: CID) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .call,
            .operands = &[_]IROperand{
                IROperand{ .string = name },
                IROperand{ .cid = function_cid },
            },
        });
    }

    pub fn emitReturn(self: *Self, value: []const u8) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .return_value,
            .operands = &[_]IROperand{IROperand{ .bytes = value }},
        });
    }

    pub fn emitReturnVoid(self: *Self) !void {
        try self.instructions.append(IRInstruction{
            .opcode = .return_void,
            .operands = &[_]IROperand{},
        });
    }

    // Placeholder implementations for other emit methods
    pub fn emitModulePrologue(self: *Self, name: []const u8) !void {
        _ = self;
        _ = name;
    }

    pub fn emitModuleEpilogue(self: *Self) !void {
        _ = self;
    }

    pub fn emitFunction(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn emitType(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn emitGlobalVariable(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn emitTypeDefinition(self: *Self, name: []const u8) !void {
        _ = self;
        _ = name;
    }

    pub fn emitField(self: *Self, name: []const u8, field_type: []const u8) !void {
        _ = self;
        _ = name;
        _ = field_type;
    }

    pub fn emitMethod(self: *Self, name: []const u8) !void {
        _ = self;
        _ = name;
    }

    pub fn emitBlock(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn emitBlockStart(self: *Self) !void {
        _ = self;
    }

    pub fn emitBlockEnd(self: *Self) !void {
        _ = self;
    }

    pub fn emitLocalVariable(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn emitAssignment(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn emitExpression(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn emitVariableDeclaration(self: *Self, name: []const u8, var_type: []const u8, is_mutable: bool) !void {
        _ = self;
        _ = name;
        _ = var_type;
        _ = is_mutable;
    }

    pub fn emitInitializer(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn emitStore(self: *Self, name: []const u8, value: []const u8) !void {
        _ = self;
        _ = name;
        _ = value;
    }

    pub fn emitArgument(self: *Self, ir_bytes: []const u8) !void {
        _ = self;
        _ = ir_bytes;
    }

    pub fn optimize(self: *Self) !void {
        // Apply IR optimizations based on config
        if (self.config.optimization_level >= 1) {
            try self.eliminateDeadCode();
        }
        if (self.config.optimization_level >= 2) {
            try self.constantFolding();
        }
        if (self.config.optimization_level >= 3) {
            try self.inlineSmallFunctions();
        }
    }

    fn eliminateDeadCode(self: *Self) !void {
        // Remove unused instructions
        _ = self;
    }

    fn constantFolding(self: *Self) !void {
        // Fold constant expressions
        _ = self;
    }

    fn inlineSmallFunctions(self: *Self) !void {
        // Inline functions below threshold
        _ = self;
    }

    pub fn getBytes(self: Self) []const u8 {
        // Serialize instructions to bytes
        // For now, return placeholder
        return "IR_BYTES_PLACEHOLDER";
    }

    pub fn getBlockBytes(self: Self) []const u8 {
        // Get bytes for current block
        return self.getBytes();
    }

    pub fn getInstructionCount(self: Self) u32 {
        return @intCast(u32, self.instructions.items.len);
    }

    pub fn getRegisterCount(self: Self) u32 {
        return @intCast(u32, self.registers.items.len);
    }

    pub fn getMemoryUsage(self: Self) u64 {
        return self.memory_usage;
    }
};

/// IR Instruction representation
const IRInstruction = struct {
    opcode: IROpcode,
    operands: []const IROperand,
};

/// IR Opcodes
const IROpcode = enum {
    nop,
    function_start,
    function_end,
    parameter,
    load_immediate_int,
    load_immediate_float,
    load_immediate_string,
    load_immediate_bool,
    load_variable,
    store_variable,
    add,
    subtract,
    multiply,
    divide,
    compare_equal,
    compare_not_equal,
    compare_less,
    compare_greater,
    call,
    return_value,
    return_void,
    jump,
    jump_if_true,
    jump_if_false,
};

/// IR Operand types
const IROperand = union(enum) {
    string: []const u8,
    bytes: []const u8,
    cid: CID,
    register: u32,
    immediate: i64,
};

/// IR Register representation
const IRRegister = struct {
    id: u32,
    type: RegisterType,
    value: ?IRValue,

    const RegisterType = enum {
        integer,
        float,
        string,
        boolean,
        pointer,
    };
};

/// IR Value representation
const IRValue = union(enum) {
    integer: i64,
    float: f64,
    string: []const u8,
    boolean: bool,
    pointer: *anyopaque,
};

// Tests
test "irOf basic functionality" {
    const allocator = std.testing.allocator;

    var args = CanonicalArgs.init(allocator);
    defer args.deinit();

    try args.append(.{ .cid = CID{ .bytes = [_]u8{1} ** 32 } });
    try args.append(.{ .cid = CID{ .bytes = [_]u8{2} ** 32 } });

    // Would call irOf here with a proper QueryCtx
    try std.testing.expect(args.items.len == 2);
}

test "IR builder basic operations" {
    const allocator = std.testing.allocator;

    const config = CodegenConfig{
        .optimization_level = 0,
        .target_arch = .x86_64,
        .debug_info = false,
        .inline_threshold = 0,
        .vectorization = false,
        .bounds_checking = false,
        .effect_tracking = false,
    };

    var builder = IRBuilder.init(allocator, config);
    defer builder.deinit();

    try builder.emitFunctionPrologue("test_function");
    try builder.emitIntegerLiteral("42");
    try builder.emitFunctionEpilogue();

    try std.testing.expect(builder.getInstructionCount() == 3);
}

test "content addressing" {
    const ir_bytes = "test_ir_content";

    var hasher = Blake3.init(.{});
    hasher.update(ir_bytes);
    const hash1 = hasher.final();

    hasher = Blake3.init(.{});
    hasher.update(ir_bytes);
    const hash2 = hasher.final();

    try std.testing.expect(std.mem.eql(u8, &hash1, &hash2));
}
