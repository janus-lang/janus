// SPDX-License-Identifier: LCL-1.0
// Copyright (c) 2026 Self Sovereign Society Foundation

//! Hypothesis Engine for Multi-Cause Analysis
//!
//! Unlike traditional compilers that report a single error cause, this engine
//! generates multiple hypotheses with probability scores. This enables:
//!
//! - Better user experience (shows the 3 most likely causes)
//! - AI-friendly output (ranked hypotheses for automated fixing)
//! - Educational value (explains why each cause is considered)
//!
//! The engine uses a Bayesian-inspired approach where:
//! - Evidence increases/decreases hypothesis probability
//! - Hypotheses compete to explain the same error
//! - Final probabilities are normalized to sum to 1.0

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.array_list.Managed;
const nextgen = @import("nextgen_diagnostic.zig");
const Hypothesis = nextgen.Hypothesis;
const HypothesisId = nextgen.HypothesisId;
const Evidence = nextgen.Evidence;
const CauseCategory = nextgen.CauseCategory;
const FixSuggestion = nextgen.FixSuggestion;
const TextEdit = nextgen.TextEdit;
const SourceSpan = nextgen.SourceSpan;
const TypeId = @import("type_registry.zig").TypeId;

/// Configuration for hypothesis generation
pub const HypothesisConfig = struct {
    /// Maximum hypotheses to generate
    max_hypotheses: u32 = 5,
    /// Minimum probability to include hypothesis
    min_probability: f32 = 0.05,
    /// Enable typo detection
    enable_typo_detection: bool = true,
    /// Maximum edit distance for typo detection
    max_typo_distance: u32 = 3,
    /// Weight for historical fix patterns
    historical_weight: f32 = 0.2,
};

/// Error context for hypothesis generation
pub const ErrorContext = struct {
    /// The symbol or expression that failed
    failed_symbol: []const u8,
    /// Expected type (if type error)
    expected_type: ?TypeId,
    /// Actual type (if type error)
    actual_type: ?TypeId,
    /// Available alternatives in scope
    available_symbols: []const SymbolInfo,
    /// Location of the error
    error_location: SourceSpan,
    /// Parent scope context
    scope_context: []const u8,

    pub const SymbolInfo = struct {
        name: []const u8,
        kind: SymbolKind,
        signature: ?[]const u8,
        visibility: Visibility,

        pub const SymbolKind = enum {
            function,
            variable,
            type_name,
            module,
            constant,
        };

        pub const Visibility = enum {
            public,
            internal,
            private,
        };
    };
};

/// Hypothesis Engine for generating multi-cause diagnostics
pub const HypothesisEngine = struct {
    allocator: Allocator,
    config: HypothesisConfig,
    next_hypothesis_id: u32,

    pub fn init(allocator: Allocator) HypothesisEngine {
        return .{
            .allocator = allocator,
            .config = .{},
            .next_hypothesis_id = 1,
        };
    }

    pub fn initWithConfig(allocator: Allocator, config: HypothesisConfig) HypothesisEngine {
        return .{
            .allocator = allocator,
            .config = config,
            .next_hypothesis_id = 1,
        };
    }

    pub fn deinit(self: *HypothesisEngine) void {
        _ = self;
        // No persistent state to clean up
    }

    /// Generate hypotheses for a "no matching function" error
    pub fn generateNoMatchHypotheses(
        self: *HypothesisEngine,
        function_name: []const u8,
        argument_types: []const TypeId,
        available_functions: []const ErrorContext.SymbolInfo,
    ) ![]Hypothesis {
        var hypotheses = ArrayList(Hypothesis).init(self.allocator);
        errdefer {
            for (hypotheses.items) |*h| {
                h.deinit(self.allocator);
            }
            hypotheses.deinit();
        }

        // Hypothesis 1: Typo in function name
        if (self.config.enable_typo_detection) {
            if (try self.generateTypoHypothesis(function_name, available_functions)) |h| {
                try hypotheses.append(h);
            }
        }

        // Hypothesis 2: Wrong argument types (needs conversion)
        if (try self.generateConversionHypothesis(function_name, argument_types, available_functions)) |h| {
            try hypotheses.append(h);
        }

        // Hypothesis 3: Missing import
        if (try self.generateMissingImportHypothesis(function_name)) |h| {
            try hypotheses.append(h);
        }

        // Hypothesis 4: Wrong argument order
        if (argument_types.len >= 2) {
            if (try self.generateWrongOrderHypothesis(function_name, argument_types, available_functions)) |h| {
                try hypotheses.append(h);
            }
        }

        // Hypothesis 5: Function doesn't exist (need to define it)
        try hypotheses.append(try self.generateUndefinedHypothesis(function_name, argument_types));

        // Normalize probabilities
        self.normalizeHypotheses(hypotheses.items);

        // Sort by probability (highest first)
        std.mem.sort(Hypothesis, hypotheses.items, {}, struct {
            fn lessThan(_: void, a: Hypothesis, b: Hypothesis) bool {
                return a.probability > b.probability;
            }
        }.lessThan);

        // Limit to max hypotheses
        if (hypotheses.items.len > self.config.max_hypotheses) {
            // Free excess hypotheses
            for (hypotheses.items[self.config.max_hypotheses..]) |*h| {
                h.deinit(self.allocator);
            }
            hypotheses.shrinkRetainingCapacity(self.config.max_hypotheses);
        }

        return try hypotheses.toOwnedSlice(alloc);
    }

    /// Generate hypotheses for an "ambiguous call" error
    pub fn generateAmbiguityHypotheses(
        self: *HypothesisEngine,
        function_name: []const u8,
        candidates: []const CandidateInfo,
    ) ![]Hypothesis {
        var hypotheses = ArrayList(Hypothesis).init(self.allocator);
        errdefer {
            for (hypotheses.items) |*h| {
                h.deinit(self.allocator);
            }
            hypotheses.deinit();
        }

        // Generate one hypothesis per candidate (different intended target)
        for (candidates, 0..) |candidate, i| {
            const h = try self.generateCandidateHypothesis(function_name, candidate, i, candidates.len);
            try hypotheses.append(h);
        }

        // Normalize probabilities
        self.normalizeHypotheses(hypotheses.items);

        return try hypotheses.toOwnedSlice(alloc);
    }

    /// Generate hypotheses for a type mismatch error
    pub fn generateTypeMismatchHypotheses(
        self: *HypothesisEngine,
        expected: TypeId,
        actual: TypeId,
        context: ErrorContext,
    ) ![]Hypothesis {
        var hypotheses = ArrayList(Hypothesis).init(self.allocator);
        errdefer {
            for (hypotheses.items) |*h| {
                h.deinit(self.allocator);
            }
            hypotheses.deinit();
        }

        // Hypothesis 1: Needs explicit cast
        try hypotheses.append(try self.generateCastHypothesis(expected, actual));

        // Hypothesis 2: Wrong variable used
        if (try self.generateWrongVariableHypothesis(expected, context)) |h| {
            try hypotheses.append(h);
        }

        // Hypothesis 3: Return type mismatch (if in function)
        if (try self.generateReturnTypeMismatchHypothesis(expected, actual, context)) |h| {
            try hypotheses.append(h);
        }

        // Normalize
        self.normalizeHypotheses(hypotheses.items);

        // Sort by probability
        std.mem.sort(Hypothesis, hypotheses.items, {}, struct {
            fn lessThan(_: void, a: Hypothesis, b: Hypothesis) bool {
                return a.probability > b.probability;
            }
        }.lessThan);

        return try hypotheses.toOwnedSlice(alloc);
    }

    // =========================================================================
    // Specific Hypothesis Generators
    // =========================================================================

    fn generateTypoHypothesis(
        self: *HypothesisEngine,
        target_name: []const u8,
        available: []const ErrorContext.SymbolInfo,
    ) !?Hypothesis {
        var best_match: ?ErrorContext.SymbolInfo = null;
        var best_distance: u32 = self.config.max_typo_distance + 1;

        for (available) |symbol| {
            const distance = levenshteinDistance(target_name, symbol.name);
            if (distance > 0 and distance <= self.config.max_typo_distance and distance < best_distance) {
                best_distance = distance;
                best_match = symbol;
            }
        }

        if (best_match) |match| {
            const hypothesis_id = self.nextId();

            // Create evidence
            var evidence = ArrayList(Evidence).init(self.allocator);
            try evidence.append(.{
                .evidence_type = .name_similarity,
                .description = try std.fmt.allocPrint(self.allocator, "'{s}' is similar to '{s}' (edit distance: {d})", .{ target_name, match.name, best_distance }),
                .location = null,
                .strength = 1.0 - (@as(f32, @floatFromInt(best_distance)) / @as(f32, @floatFromInt(self.config.max_typo_distance + 1))),
            });

            // Create fix
            var fixes = ArrayList(FixSuggestion).init(self.allocator);
            var edits = try self.allocator.alloc(TextEdit, 1);
            edits[0] = .{
                .span = .{},
                .replacement = try self.allocator.dupe(u8, match.name),
            };

            try fixes.append(.{
                .id = try std.fmt.allocPrint(self.allocator, "typo_fix_{d}", .{hypothesis_id.id}),
                .description = try std.fmt.allocPrint(self.allocator, "Replace '{s}' with '{s}'", .{ target_name, match.name }),
                .confidence = 0.9 - (@as(f32, @floatFromInt(best_distance)) * 0.15),
                .edits = edits,
                .hypothesis_id = hypothesis_id,
                .acceptance_rate = 0.85,
                .requires_user_input = false,
            });

            return Hypothesis{
                .id = hypothesis_id,
                .cause_category = .typo,
                .probability = 0.7 - (@as(f32, @floatFromInt(best_distance)) * 0.1),
                .explanation = try std.fmt.allocPrint(self.allocator, "The identifier '{s}' may be a typo. Did you mean '{s}'?", .{ target_name, match.name }),
                .evidence = try evidence.toOwnedSlice(),
                .counter_evidence = &[_]Evidence{},
                .targeted_fixes = try fixes.toOwnedSlice(),
            };
        }

        return null;
    }

    fn generateConversionHypothesis(
        self: *HypothesisEngine,
        function_name: []const u8,
        argument_types: []const TypeId,
        available: []const ErrorContext.SymbolInfo,
    ) !?Hypothesis {
        // Find function with same name that could match with conversions
        for (available) |symbol| {
            if (std.mem.eql(u8, symbol.name, function_name)) {
                const hypothesis_id = self.nextId();

                var evidence = ArrayList(Evidence).init(self.allocator);
                try evidence.append(.{
                    .evidence_type = .signature_match,
                    .description = try std.fmt.allocPrint(self.allocator, "Function '{s}' exists with different parameter types", .{function_name}),
                    .location = null,
                    .strength = 0.7,
                });

                var fixes = ArrayList(FixSuggestion).init(self.allocator);

                // Generate cast suggestion for each argument
                for (argument_types, 0..) |_, i| {
                    var edits = try self.allocator.alloc(TextEdit, 1);
                    edits[0] = .{
                        .span = .{},
                        .replacement = try std.fmt.allocPrint(self.allocator, "arg_{d} as TargetType", .{i}),
                    };

                    try fixes.append(.{
                        .id = try std.fmt.allocPrint(self.allocator, "cast_arg_{d}", .{i}),
                        .description = try std.fmt.allocPrint(self.allocator, "Cast argument {d} to match function signature", .{i}),
                        .confidence = 0.75,
                        .edits = edits,
                        .hypothesis_id = hypothesis_id,
                        .acceptance_rate = 0.7,
                        .requires_user_input = false,
                    });
                }

                return Hypothesis{
                    .id = hypothesis_id,
                    .cause_category = .missing_conversion,
                    .probability = 0.6,
                    .explanation = try std.fmt.allocPrint(self.allocator, "Function '{s}' exists but requires explicit type conversion for the arguments", .{function_name}),
                    .evidence = try evidence.toOwnedSlice(),
                    .counter_evidence = &[_]Evidence{},
                    .targeted_fixes = try fixes.toOwnedSlice(),
                };
            }
        }

        return null;
    }

    fn generateMissingImportHypothesis(self: *HypothesisEngine, function_name: []const u8) !?Hypothesis {
        const hypothesis_id = self.nextId();

        var evidence = ArrayList(Evidence).init(self.allocator);
        try evidence.append(.{
            .evidence_type = .pattern_match,
            .description = try std.fmt.allocPrint(self.allocator, "'{s}' might be defined in an external module", .{function_name}),
            .location = null,
            .strength = 0.4,
        });

        var fixes = ArrayList(FixSuggestion).init(self.allocator);
        var edits = try self.allocator.alloc(TextEdit, 1);
        edits[0] = .{
            .span = .{},
            .replacement = try std.fmt.allocPrint(self.allocator, "import std.{s};", .{function_name}),
        };

        try fixes.append(.{
            .id = try std.fmt.allocPrint(self.allocator, "import_fix_{d}", .{hypothesis_id.id}),
            .description = try self.allocator.dupe(u8, "Add import statement (speculative)"),
            .confidence = 0.3,
            .edits = edits,
            .hypothesis_id = hypothesis_id,
            .acceptance_rate = 0.5,
            .requires_user_input = true, // User needs to specify module
        });

        return Hypothesis{
            .id = hypothesis_id,
            .cause_category = .wrong_import,
            .probability = 0.3,
            .explanation = try std.fmt.allocPrint(self.allocator, "The function '{s}' might exist in a module that hasn't been imported", .{function_name}),
            .evidence = try evidence.toOwnedSlice(),
            .counter_evidence = &[_]Evidence{},
            .targeted_fixes = try fixes.toOwnedSlice(),
        };
    }

    fn generateWrongOrderHypothesis(
        self: *HypothesisEngine,
        function_name: []const u8,
        argument_types: []const TypeId,
        available: []const ErrorContext.SymbolInfo,
    ) !?Hypothesis {
        _ = available;

        const hypothesis_id = self.nextId();

        var evidence = ArrayList(Evidence).init(self.allocator);
        try evidence.append(.{
            .evidence_type = .pattern_match,
            .description = try self.allocator.dupe(u8, "Multiple arguments of different types may be swapped"),
            .location = null,
            .strength = 0.3,
        });

        var fixes = ArrayList(FixSuggestion).init(self.allocator);

        // Suggest swapping first two arguments as a common case
        if (argument_types.len >= 2) {
            var edits = try self.allocator.alloc(TextEdit, 1);
            edits[0] = .{
                .span = .{},
                .replacement = try std.fmt.allocPrint(self.allocator, "{s}(arg_1, arg_0)", .{function_name}),
            };

            try fixes.append(.{
                .id = try std.fmt.allocPrint(self.allocator, "swap_args_{d}", .{hypothesis_id.id}),
                .description = try self.allocator.dupe(u8, "Swap argument order"),
                .confidence = 0.4,
                .edits = edits,
                .hypothesis_id = hypothesis_id,
                .acceptance_rate = 0.3,
                .requires_user_input = false,
            });
        }

        return Hypothesis{
            .id = hypothesis_id,
            .cause_category = .wrong_argument_order,
            .probability = 0.2,
            .explanation = try std.fmt.allocPrint(self.allocator, "Arguments to '{s}' may be in the wrong order", .{function_name}),
            .evidence = try evidence.toOwnedSlice(),
            .counter_evidence = &[_]Evidence{},
            .targeted_fixes = try fixes.toOwnedSlice(),
        };
    }

    fn generateUndefinedHypothesis(
        self: *HypothesisEngine,
        function_name: []const u8,
        argument_types: []const TypeId,
    ) !Hypothesis {
        const hypothesis_id = self.nextId();

        var evidence = ArrayList(Evidence).init(self.allocator);
        // This is the fallback - low evidence but always possible

        var fixes = ArrayList(FixSuggestion).init(self.allocator);

        // Generate function definition template
        var sig_buf = ArrayList(u8).init(self.allocator);
        try sig_buf.writer().print("func {s}(", .{function_name});
        for (argument_types, 0..) |_, i| {
            if (i > 0) try sig_buf.appendSlice(", ");
            try sig_buf.writer().print("arg_{d}: T{d}", .{ i, i });
        }
        try sig_buf.appendSlice(") -> ReturnType {\n    // TODO: implement\n}");

        var edits = try self.allocator.alloc(TextEdit, 1);
        edits[0] = .{
            .span = .{},
            .replacement = try sig_buf.toOwnedSlice(),
        };

        try fixes.append(.{
            .id = try std.fmt.allocPrint(self.allocator, "define_func_{d}", .{hypothesis_id.id}),
            .description = try std.fmt.allocPrint(self.allocator, "Define function '{s}'", .{function_name}),
            .confidence = 0.5,
            .edits = edits,
            .hypothesis_id = hypothesis_id,
            .acceptance_rate = 0.4,
            .requires_user_input = true,
        });

        return Hypothesis{
            .id = hypothesis_id,
            .cause_category = .scope_error,
            .probability = 0.15,
            .explanation = try std.fmt.allocPrint(self.allocator, "Function '{s}' is not defined. You may need to create it.", .{function_name}),
            .evidence = try evidence.toOwnedSlice(),
            .counter_evidence = &[_]Evidence{},
            .targeted_fixes = try fixes.toOwnedSlice(),
        };
    }

    fn generateCandidateHypothesis(
        self: *HypothesisEngine,
        function_name: []const u8,
        candidate: CandidateInfo,
        index: usize,
        total: usize,
    ) !Hypothesis {
        const hypothesis_id = self.nextId();

        var evidence = ArrayList(Evidence).init(self.allocator);
        try evidence.append(.{
            .evidence_type = .signature_match,
            .description = try std.fmt.allocPrint(self.allocator, "Candidate from {s} matches with conversion", .{candidate.module_path}),
            .location = candidate.definition_location,
            .strength = 0.5,
        });

        var fixes = ArrayList(FixSuggestion).init(self.allocator);

        // Fix 1: Use qualified name
        if (candidate.module_path.len > 0) {
            var edits = try self.allocator.alloc(TextEdit, 1);
            edits[0] = .{
                .span = .{},
                .replacement = try std.fmt.allocPrint(self.allocator, "{s}.{s}", .{ candidate.module_path, function_name }),
            };

            try fixes.append(.{
                .id = try std.fmt.allocPrint(self.allocator, "qualified_{d}", .{index}),
                .description = try std.fmt.allocPrint(self.allocator, "Use fully qualified name: {s}.{s}", .{ candidate.module_path, function_name }),
                .confidence = 0.8,
                .edits = edits,
                .hypothesis_id = hypothesis_id,
                .acceptance_rate = 0.7,
                .requires_user_input = false,
            });
        }

        // Fix 2: Cast arguments to match this candidate
        var cast_edits = try self.allocator.alloc(TextEdit, 1);
        cast_edits[0] = .{
            .span = .{},
            .replacement = try std.fmt.allocPrint(self.allocator, "{s}(/* cast arguments to match {s} */)", .{ function_name, candidate.signature }),
        };

        try fixes.append(.{
            .id = try std.fmt.allocPrint(self.allocator, "cast_for_{d}", .{index}),
            .description = try std.fmt.allocPrint(self.allocator, "Cast arguments to match: {s}", .{candidate.signature}),
            .confidence = 0.7,
            .edits = cast_edits,
            .hypothesis_id = hypothesis_id,
            .acceptance_rate = 0.6,
            .requires_user_input = false,
        });

        // Probability is equal among candidates initially
        const base_prob = 1.0 / @as(f32, @floatFromInt(total));

        return Hypothesis{
            .id = hypothesis_id,
            .cause_category = .ambiguous_dispatch,
            .probability = base_prob,
            .explanation = try std.fmt.allocPrint(self.allocator, "You may have intended to call: {s} from {s}", .{ candidate.signature, candidate.module_path }),
            .evidence = try evidence.toOwnedSlice(),
            .counter_evidence = &[_]Evidence{},
            .targeted_fixes = try fixes.toOwnedSlice(),
        };
    }

    fn generateCastHypothesis(self: *HypothesisEngine, expected: TypeId, actual: TypeId) !Hypothesis {
        const hypothesis_id = self.nextId();

        var evidence = ArrayList(Evidence).init(self.allocator);
        try evidence.append(.{
            .evidence_type = .conversion_available,
            .description = try self.allocator.dupe(u8, "Types may be convertible with explicit cast"),
            .location = null,
            .strength = 0.7,
        });

        var fixes = ArrayList(FixSuggestion).init(self.allocator);
        var edits = try self.allocator.alloc(TextEdit, 1);
        edits[0] = .{
            .span = .{},
            .replacement = try std.fmt.allocPrint(self.allocator, "expr as {s}", .{typeIdToName(expected)}),
        };

        try fixes.append(.{
            .id = try std.fmt.allocPrint(self.allocator, "cast_{d}", .{hypothesis_id.id}),
            .description = try std.fmt.allocPrint(self.allocator, "Cast from {s} to {s}", .{ typeIdToName(actual), typeIdToName(expected) }),
            .confidence = 0.85,
            .edits = edits,
            .hypothesis_id = hypothesis_id,
            .acceptance_rate = 0.8,
            .requires_user_input = false,
        });

        return Hypothesis{
            .id = hypothesis_id,
            .cause_category = .missing_conversion,
            .probability = 0.7,
            .explanation = try std.fmt.allocPrint(self.allocator, "Expression has type '{s}' but '{s}' is expected. An explicit cast may be needed.", .{ typeIdToName(actual), typeIdToName(expected) }),
            .evidence = try evidence.toOwnedSlice(),
            .counter_evidence = &[_]Evidence{},
            .targeted_fixes = try fixes.toOwnedSlice(),
        };
    }

    fn generateWrongVariableHypothesis(
        self: *HypothesisEngine,
        expected: TypeId,
        context: ErrorContext,
    ) !?Hypothesis {
        // Look for a variable with the expected type
        for (context.available_symbols) |symbol| {
            if (symbol.kind == .variable) {
                // In a real implementation, we'd check the symbol's type
                const hypothesis_id = self.nextId();

                var evidence = ArrayList(Evidence).init(self.allocator);
                try evidence.append(.{
                    .evidence_type = .pattern_match,
                    .description = try std.fmt.allocPrint(self.allocator, "Variable '{s}' exists in scope", .{symbol.name}),
                    .location = null,
                    .strength = 0.4,
                });

                var fixes = ArrayList(FixSuggestion).init(self.allocator);
                var edits = try self.allocator.alloc(TextEdit, 1);
                edits[0] = .{
                    .span = .{},
                    .replacement = try self.allocator.dupe(u8, symbol.name),
                };

                try fixes.append(.{
                    .id = try std.fmt.allocPrint(self.allocator, "use_var_{d}", .{hypothesis_id.id}),
                    .description = try std.fmt.allocPrint(self.allocator, "Use '{s}' instead (type: {s})", .{ symbol.name, typeIdToName(expected) }),
                    .confidence = 0.5,
                    .edits = edits,
                    .hypothesis_id = hypothesis_id,
                    .acceptance_rate = 0.4,
                    .requires_user_input = false,
                });

                return Hypothesis{
                    .id = hypothesis_id,
                    .cause_category = .typo,
                    .probability = 0.3,
                    .explanation = try std.fmt.allocPrint(self.allocator, "Did you mean to use '{s}' which has the expected type?", .{symbol.name}),
                    .evidence = try evidence.toOwnedSlice(),
                    .counter_evidence = &[_]Evidence{},
                    .targeted_fixes = try fixes.toOwnedSlice(),
                };
            }
        }
        return null;
    }

    fn generateReturnTypeMismatchHypothesis(
        self: *HypothesisEngine,
        expected: TypeId,
        actual: TypeId,
        context: ErrorContext,
    ) !?Hypothesis {
        if (!std.mem.containsAtLeast(u8, context.scope_context, 1, "function")) {
            return null;
        }

        const hypothesis_id = self.nextId();

        var evidence = ArrayList(Evidence).init(self.allocator);
        try evidence.append(.{
            .evidence_type = .pattern_match,
            .description = try self.allocator.dupe(u8, "Error occurs in function context"),
            .location = null,
            .strength = 0.5,
        });

        var fixes = ArrayList(FixSuggestion).init(self.allocator);

        // Fix 1: Change return type
        var edits1 = try self.allocator.alloc(TextEdit, 1);
        edits1[0] = .{
            .span = .{},
            .replacement = try std.fmt.allocPrint(self.allocator, "-> {s}", .{typeIdToName(actual)}),
        };

        try fixes.append(.{
            .id = try std.fmt.allocPrint(self.allocator, "change_return_{d}", .{hypothesis_id.id}),
            .description = try std.fmt.allocPrint(self.allocator, "Change function return type to {s}", .{typeIdToName(actual)}),
            .confidence = 0.6,
            .edits = edits1,
            .hypothesis_id = hypothesis_id,
            .acceptance_rate = 0.5,
            .requires_user_input = true,
        });

        // Fix 2: Convert return value
        var edits2 = try self.allocator.alloc(TextEdit, 1);
        edits2[0] = .{
            .span = .{},
            .replacement = try std.fmt.allocPrint(self.allocator, "return expr as {s};", .{typeIdToName(expected)}),
        };

        try fixes.append(.{
            .id = try std.fmt.allocPrint(self.allocator, "convert_return_{d}", .{hypothesis_id.id}),
            .description = try std.fmt.allocPrint(self.allocator, "Convert return value to {s}", .{typeIdToName(expected)}),
            .confidence = 0.7,
            .edits = edits2,
            .hypothesis_id = hypothesis_id,
            .acceptance_rate = 0.6,
            .requires_user_input = false,
        });

        return Hypothesis{
            .id = hypothesis_id,
            .cause_category = .type_mismatch,
            .probability = 0.4,
            .explanation = try std.fmt.allocPrint(self.allocator, "Function's declared return type ({s}) doesn't match the actual return value type ({s})", .{ typeIdToName(expected), typeIdToName(actual) }),
            .evidence = try evidence.toOwnedSlice(),
            .counter_evidence = &[_]Evidence{},
            .targeted_fixes = try fixes.toOwnedSlice(),
        };
    }

    // =========================================================================
    // Utility Functions
    // =========================================================================

    fn nextId(self: *HypothesisEngine) HypothesisId {
        const id = HypothesisId{ .id = self.next_hypothesis_id };
        self.next_hypothesis_id += 1;
        return id;
    }

    fn normalizeHypotheses(self: *HypothesisEngine, hypotheses: []Hypothesis) void {
        _ = self;

        if (hypotheses.len == 0) return;

        var sum: f32 = 0;
        for (hypotheses) |h| {
            sum += h.probability;
        }

        if (sum > 0) {
            for (hypotheses) |*h| {
                h.probability /= sum;
            }
        }
    }
};

/// Candidate information for ambiguity resolution
pub const CandidateInfo = struct {
    signature: []const u8,
    module_path: []const u8,
    definition_location: ?SourceSpan,
    conversion_cost: u32,
};

// =============================================================================
// Helper Functions
// =============================================================================

/// Levenshtein edit distance between two strings
fn levenshteinDistance(a: []const u8, b: []const u8) u32 {
    if (a.len == 0) return @intCast(b.len);
    if (b.len == 0) return @intCast(a.len);

    const m = a.len + 1;
    const n = b.len + 1;

    // Use a simple O(m*n) implementation with stack allocation for small strings
    if (m * n <= 256) {
        var matrix: [256]u32 = undefined;

        // Initialize first row
        for (0..n) |j| {
            matrix[j] = @intCast(j);
        }

        // Fill matrix
        for (1..m) |i| {
            matrix[i * n] = @intCast(i);

            for (1..n) |j| {
                const cost: u32 = if (a[i - 1] == b[j - 1]) 0 else 1;
                matrix[i * n + j] = @min(
                    matrix[(i - 1) * n + j] + 1,
                    @min(
                        matrix[i * n + (j - 1)] + 1,
                        matrix[(i - 1) * n + (j - 1)] + cost,
                    ),
                );
            }
        }

        return matrix[(m - 1) * n + (n - 1)];
    }

    // For larger strings, return a rough estimate
    if (a.len > b.len) {
        return @intCast(a.len - b.len);
    }
    return @intCast(b.len - a.len);
}

/// Convert TypeId to string name (simplified)
fn typeIdToName(type_id: TypeId) []const u8 {
    return switch (type_id.id) {
        0 => "invalid",
        1 => "i32",
        2 => "f64",
        3 => "bool",
        4 => "string",
        else => "unknown",
    };
}

// =============================================================================
// Tests
// =============================================================================

test "HypothesisEngine initialization" {
    const allocator = std.testing.allocator;
    var engine = HypothesisEngine.init(allocator);
    defer engine.deinit();

    try std.testing.expect(engine.config.max_hypotheses == 5);
    try std.testing.expect(engine.config.enable_typo_detection);
}

test "Levenshtein distance" {
    try std.testing.expectEqual(@as(u32, 0), levenshteinDistance("test", "test"));
    try std.testing.expectEqual(@as(u32, 1), levenshteinDistance("test", "tests"));
    // "test" -> "tset" requires 2 substitutions in standard Levenshtein
    try std.testing.expectEqual(@as(u32, 2), levenshteinDistance("test", "tset"));
    // "test" -> "best" requires 1 substitution (t->b)
    try std.testing.expectEqual(@as(u32, 1), levenshteinDistance("test", "best"));
    try std.testing.expectEqual(@as(u32, 4), levenshteinDistance("", "test"));
}

test "Generate hypotheses for no match" {
    const allocator = std.testing.allocator;
    var engine = HypothesisEngine.init(allocator);
    defer engine.deinit();

    const available = [_]ErrorContext.SymbolInfo{
        .{
            .name = "calculate",
            .kind = .function,
            .signature = "func calculate(i32, i32) -> i32",
            .visibility = .public,
        },
    };

    const hypotheses = try engine.generateNoMatchHypotheses(
        "calculte", // Typo
        &[_]TypeId{ TypeId.I32, TypeId.F64 },
        &available,
    );
    defer {
        for (@constCast(hypotheses)) |*h| {
            h.deinit(allocator);
        }
        allocator.free(hypotheses);
    }

    try std.testing.expect(hypotheses.len > 0);

    // First hypothesis should have highest probability
    if (hypotheses.len > 1) {
        try std.testing.expect(hypotheses[0].probability >= hypotheses[1].probability);
    }
}
