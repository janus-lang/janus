// SPDX-License-Identifier: LUL-1.0
// Copyright (c) 2026 Self Sovereign Society Foundation

const std = @import("std");
const Manifest = @import("manifest.zig").Manifest;
const Lockfile = @import("manifest.zig").Lockfile;

// Resolver implements dependency resolution with deterministic semantics
pub const Resolver = struct {
    allocator: std.mem.Allocator,
    manifest: *const Manifest,
    registry_client: RegistryClient,
    resolved_packages: std.StringHashMap(*ResolvedPackage),
    resolution_order: std.ArrayList([]const u8),

    pub const ResolvedPackage = struct {
        name: []const u8,
        version: []const u8,
        source: Lockfile.Source,
        digest: []const u8,
        size: u64,
        capabilities: []const []const u8,
        deps: []const []const u8,
        license: []const u8,
        sbom: []const u8,
        signatures: []const Lockfile.Signature,
        ledger: ?Lockfile.LedgerProof,

        pub fn deinit(self: *ResolvedPackage, allocator: std.mem.Allocator) void {
            allocator.free(self.name);
            allocator.free(self.version);
            allocator.free(self.digest);
            allocator.free(self.license);
            allocator.free(self.sbom);
            allocator.free(self.source.url);

            for (self.capabilities) |cap| {
                allocator.free(cap);
            }
            allocator.free(self.capabilities);

            for (self.deps) |dep| {
                allocator.free(dep);
            }
            allocator.free(self.deps);

            for (self.signatures) |sig| {
                allocator.free(sig.key);
                allocator.free(sig.sig);
                allocator.free(sig.timestamp);
            }
            allocator.free(self.signatures);

            if (self.ledger) |*ledger| {
                allocator.free(ledger.tx);
                allocator.free(ledger.inclusion_proof);
            }
        }
    };

    pub const RegistryClient = struct {
        allocator: std.mem.Allocator,

        pub fn fetchPackageInfo(self: *const RegistryClient, name: []const u8, version: []const u8) !PackageInfo {
            // Mock implementation - in real version would fetch from registry
            const mock_digest = try std.fmt.allocPrint(self.allocator, "blake3-256:mock_{s}_{s}", .{ name, version });

            var deps: std.ArrayList([]const u8) = .empty;
            defer deps.deinit();

            // Add some mock dependencies for testing
            if (std.mem.eql(u8, name, "std/log")) {
                try deps.append(try self.allocator.dupe(u8, "blake3-256:mock_blake3_1.3.0"));
                try deps.append(try self.allocator.dupe(u8, "blake3-256:mock_serde_0.7.0"));
            }

            return PackageInfo{
                .name = try self.allocator.dupe(u8, name),
                .version = try self.allocator.dupe(u8, version),
                .digest = mock_digest,
                .size = 1024, // Mock size
                .capabilities = &.{"fs.read"},
                .deps = try deps.toOwnedSlice(),
                .license = try self.allocator.dupe(u8, "Apache-2.0"),
                .sbom = try std.fmt.allocPrint(self.allocator, "blake3-256:sbom_{s}_{s}", .{ name, version }),
            };
        }

        pub fn deinit(_: *RegistryClient) void {
            // Cleanup if needed
        }
    };

    pub const PackageInfo = struct {
        name: []const u8,
        version: []const u8,
        digest: []const u8,
        size: u64,
        capabilities: []const []const u8,
        deps: []const []const u8,
        license: []const u8,
        sbom: []const u8,

        pub fn deinit(self: *const PackageInfo, allocator: std.mem.Allocator) void {
            allocator.free(self.name);
            allocator.free(self.version);
            allocator.free(self.digest);
            allocator.free(self.license);
            allocator.free(self.sbom);

            for (self.capabilities) |cap| {
                allocator.free(cap);
            }
            allocator.free(self.capabilities);

            for (self.deps) |dep| {
                allocator.free(dep);
            }
            allocator.free(self.deps);
        }
    };

    pub fn init(allocator: std.mem.Allocator, manifest: *const Manifest) Resolver {
        return .{
            .allocator = allocator,
            .manifest = manifest,
            .registry_client = .{ .allocator = allocator },
            .resolved_packages = std.StringHashMap(*ResolvedPackage).init(allocator),
            .resolution_order = std.ArrayList([]const u8).init(allocator),
        };
    }

    pub fn deinit(self: *Resolver) void {
        self.registry_client.deinit();

        var pkg_iter = self.resolved_packages.iterator();
        while (pkg_iter.next()) |entry| {
            entry.value_ptr.*.deinit(self.allocator);
            self.allocator.destroy(entry.value_ptr.*);
        }
        self.resolved_packages.deinit();

        for (self.resolution_order.items) |name| {
            self.allocator.free(name);
        }
        self.resolution_order.deinit();
    }

    // Main resolution algorithm
    pub fn resolve(self: *Resolver) !Lockfile {
        // Clear previous resolution
        var pkg_iter = self.resolved_packages.iterator();
        while (pkg_iter.next()) |entry| {
            entry.value_ptr.*.deinit(self.allocator);
            self.allocator.destroy(entry.value_ptr.*);
        }
        self.resolved_packages.deinit();
        self.resolved_packages = std.StringHashMap(*ResolvedPackage).init(self.allocator);

        for (self.resolution_order.items) |name| {
            self.allocator.free(name);
        }
        self.resolution_order.deinit();
        self.resolution_order = std.ArrayList([]const u8).init(self.allocator);

        // Resolve all dependencies from manifest
        var dep_iter = self.manifest.dependencies.iterator();
        while (dep_iter.next()) |entry| {
            try self.resolvePackage(entry.key_ptr.*, entry.value_ptr.version);
        }

        // Build lockfile from resolved packages
        var packages: std.ArrayList(Lockfile.Package) = .empty;
        defer packages.deinit();

        for (self.resolution_order.items) |pkg_name| {
            const resolved = self.resolved_packages.get(pkg_name).?;

            const pkg = Lockfile.Package{
                .name = try self.allocator.dupe(u8, resolved.name),
                .version = try self.allocator.dupe(u8, resolved.version),
                .source = .{
                    .type_ = try self.allocator.dupe(u8, "registry"),
                    .url = try self.allocator.dupe(u8, self.manifest.registry),
                },
                .digest = try self.allocator.dupe(u8, resolved.digest),
                .size = resolved.size,
                .capabilities = try self.allocator.dupe([]const u8, resolved.capabilities),
                .deps = try self.allocator.dupe([]const u8, resolved.deps),
                .license = try self.allocator.dupe(u8, resolved.license),
                .sbom = try self.allocator.dupe(u8, resolved.sbom),
                .signatures = &.{}, // Empty for now
                .ledger = null, // Empty for now
            };

            try packages.append(pkg);
        }

        // Create lockfile
        var lockfile = Lockfile.init(self.allocator);
        lockfile.project = self.manifest.project;
        lockfile.packages = try packages.toOwnedSlice();
        lockfile.policy.capabilities = .{
            .required = try self.allocator.dupe([]const u8, self.manifest.capabilities.required),
            .forbid = try self.allocator.dupe([]const u8, self.manifest.capabilities.forbidden),
        };

        return lockfile;
    }

    // Resolve a single package and its dependencies
    fn resolvePackage(self: *Resolver, name: []const u8, version_spec: []const u8) !void {
        // Check if already resolved
        if (self.resolved_packages.contains(name)) {
            return;
        }

        // Fetch package info from registry
        const pkg_info = try self.registry_client.fetchPackageInfo(name, version_spec);
        defer pkg_info.deinit(self.allocator);

        // Create resolved package
        const resolved = try self.allocator.create(ResolvedPackage);
        resolved.* = .{
            .name = try self.allocator.dupe(u8, pkg_info.name),
            .version = try self.allocator.dupe(u8, pkg_info.version),
            .source = .{
                .type_ = try self.allocator.dupe(u8, "registry"),
                .url = try self.allocator.dupe(u8, self.manifest.registry),
            },
            .digest = try self.allocator.dupe(u8, pkg_info.digest),
            .size = pkg_info.size,
            .capabilities = try self.allocator.dupe([]const u8, pkg_info.capabilities),
            .deps = try self.allocator.dupe([]const u8, pkg_info.deps),
            .license = try self.allocator.dupe(u8, pkg_info.license),
            .sbom = try self.allocator.dupe(u8, pkg_info.sbom),
            .signatures = &.{},
            .ledger = null,
        };

        // Store resolved package
        try self.resolved_packages.put(name, resolved);
        try self.resolution_order.append(try self.allocator.dupe(u8, name));

        // Recursively resolve dependencies
        for (pkg_info.deps) |_| {
            // Extract package name from digest (simplified parsing)
            // In real implementation, would parse the multihash format
            const dep_name = try std.fmt.allocPrint(self.allocator, "dep_from_{s}", .{name});
            const dep_version = "latest";

            try self.resolvePackage(dep_name, dep_version);
        }
    }

    // Deterministic sorting for consistent lockfiles
    pub fn sortPackages(packages: []Lockfile.Package) void {
        std.mem.sort(Lockfile.Package, packages, {}, struct {
            fn lessThan(_: void, a: Lockfile.Package, b: Lockfile.Package) bool {
                // Sort by name ASC, then version DESC
                const name_cmp = std.mem.order(u8, a.name, b.name);
                if (name_cmp == .lt) return true;
                if (name_cmp == .gt) return false;

                // For same name, higher version first
                return std.mem.order(u8, a.version, b.version) == .gt;
            }
        }.lessThan);
    }
};

// Version specification parsing and matching
pub const VersionSpec = struct {
    pub const Constraint = union(enum) {
        exact: []const u8,
        range: Range,
        wildcard: Wildcard,
    };

    pub const Range = struct {
        min: []const u8,
        max: []const u8,
        include_min: bool,
        include_max: bool,
    };

    pub const Wildcard = struct {
        prefix: []const u8,
        suffix: []const u8,
    };

    pub fn parse(spec: []const u8) !Constraint {
        if (std.mem.startsWith(u8, spec, "^")) {
            // Caret range: ^1.2.3 means >=1.2.3 <2.0.0
            return Constraint{ .range = .{
                .min = spec[1..],
                .max = incrementMajor(spec[1..]),
                .include_min = true,
                .include_max = false,
            } };
        } else if (std.mem.startsWith(u8, spec, "~")) {
            // Tilde range: ~1.2.3 means >=1.2.3 <1.3.0
            return Constraint{ .range = .{
                .min = spec[1..],
                .max = incrementMinor(spec[1..]),
                .include_min = true,
                .include_max = false,
            } };
        } else if (std.mem.containsAtLeast(u8, spec, 1, "x") or std.mem.containsAtLeast(u8, spec, 1, "*")) {
            // Wildcard
            return Constraint{ .wildcard = parseWildcard(spec) };
        } else {
            // Exact version
            return Constraint{ .exact = spec };
        }
    }

    fn incrementMajor(version: []const u8) []const u8 {
        // Simplified version incrementing
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}.0.0", .{try std.fmt.parseInt(u32, version.split(".").next().?, 10) + 1}) catch version;
    }

    fn incrementMinor(version: []const u8) []const u8 {
        // Simplified version incrementing
        var parts = std.mem.split(u8, version, ".");
        const major = parts.next().?;
        const minor = parts.next().?;
        const patch = parts.next().?;

        const new_minor = try std.fmt.parseInt(u32, minor, 10) + 1;
        return std.fmt.allocPrint(std.heap.page_allocator, "{s}.{d}.{s}", .{ major, new_minor, patch }) catch version;
    }

    fn parseWildcard(_: []const u8) Wildcard {
        // Simplified wildcard parsing
        return .{ .prefix = "", .suffix = "" };
    }
};

// BLAKE3 content addressing
pub const ContentAddress = struct {
    pub fn compute(data: []const u8) []const u8 {
        // Mock BLAKE3 computation - in real implementation would use BLAKE3
        const mock_hash = std.crypto.hash.Blake3.hash(data);
        // Convert to hex manually (page_allocator is used for this mock)
        const allocator = std.heap.page_allocator;
        const packer = @import("packer.zig");
        const hash_hex = packer.hexSlice(allocator, &mock_hash) catch return "mock-hash";
        return std.fmt.allocPrint(allocator, "blake3-256:{s}", .{hash_hex}) catch "mock-hash";
    }

    pub fn parse(address: []const u8) !struct { []const u8, []const u8 } {
        if (!std.mem.startsWith(u8, address, "blake3-256:")) {
            return error.InvalidContentAddress;
        }
        return .{ "blake3", address[11..] };
    }
};
