// SPDX-License-Identifier: LCL-1.0
// Copyright (c) 2026 Self Sovereign Society Foundation

// Quicksort Algorithm
//
// Demonstrates:
// - Array manipulation
// - Algorithms implementation
// - Pass-by-reference (via slices)
// - Native performance (O(n log n) sorting)
// - Real-world programming patterns

func swap(arr: []i64, i: i64, j: i64) do
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
end

func partition(arr: []i64, low: i64, high: i64) -> i64 do
    let pivot = arr[high]
    var i = low - 1

    for j in low..<high do
        if arr[j] <= pivot do
            i = i + 1
            swap(arr, i, j)
        end
    end

    swap(arr, i + 1, high)
    return i + 1
end

func quicksort(arr: []i64, low: i64, high: i64) do
    if low < high do
        let pivot_index = partition(arr, low, high)

        // Recursively sort left and right partitions
        quicksort(arr, low, pivot_index - 1)
        quicksort(arr, pivot_index + 1, high)
    end
end

func print_array(arr: []i64) do
    print("[")
    for i in 0..<arr.len do
        print_int(arr[i])
        if i < arr.len - 1 do
            print(", ")
        end
    end
    println("]")
end

func main() do
    // Create an unsorted array
    var numbers = [64, 34, 25, 12, 22, 11, 90, 88, 45, 50, 33, 17, 29, 82, 5]

    println("Original array:")
    print_array(numbers)

    // Sort the array
    quicksort(numbers, 0, numbers.len - 1)

    println("\nSorted array:")
    print_array(numbers)

    println("\nâœ“ Native O(n log n) performance!")
end
