// SPDX-License-Identifier: LSL-1.0
// Copyright (c) 2026 Self Sovereign Society Foundation

//! LSP Keyword Support for Janus v1.0
//!
//! This module provides comprehensive LSP support for Janus keywords,
//! including the new `when` keyword for guard clauses and postfix conditionals.

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.array_list.Managed;

/// Janus keyword definitions for LSP support
pub const JanusKeyword = struct {
    name: []const u8,
    kind: KeywordKind,
    profile: LanguageProfile,
    description: []const u8,
    examples: []const []const u8,

    pub const KeywordKind = enum {
        control_flow,
        declaration,
        block_delimiter,
        capability,
        concurrency,
        metaprogramming,
    };

    pub const LanguageProfile = enum {
        min,
        go,
        elixir,
        full,
        post_1erved for future features
    };
};

/// Complete keyword registry for Janus 1.0
pub const JANUS_KEYWORDS = [_]JanusKeyword{
    // Core language keywords (:min profile)
    .{
        .name = "func",
        .kind = .declaration,
        .profile = .min,
        .description = "Function declaration",
        .examples = &[_][]const u8{
            "func add(a: i32, b: i32) -> i32 { return a + b }",
            "func greet(name: string) -> void { print(\"Hello, {}!\", name) }",
        },
    },
    .{
        .name = "let",
        .kind = .declaration,
        .profile = .min,
        .description = "Immutable variable binding",
        .examples = &[_][]const u8{
            "let name = \"Alice\"",
            "let result = calculate(x, y)",
        },
    },
    .{
        .name = "var",
        .kind = .declaration,
        .profile = .min,
        .description = "Mutable variable declaration",
        .examples = &[_][]const u8{
            "var counter = 0",
            "var items = []",
        },
    },
    .{
        .name = "if",
        .kind = .control_flow,
        .profile = .min,
        .description = "Conditional statement",
        .examples = &[_][]const u8{
            "if x > 0 do print(\"positive\") end",
            "if user.is_active do process(user) else skip() end",
        },
    },
    .{
        .name = "else",
        .kind = .control_flow,
        .profile = .min,
        .description = "Alternative branch in conditional",
        .examples = &[_][]const u8{
            "if condition do action() else alternative() end",
        },
    },
    .{
        .name = "for",
        .kind = .control_flow,
        .profile = .min,
        .description = "Loop construct",
        .examples = &[_][]const u8{
            "for i in 0..10 do print(i) end",
            "for item in items do process(item) end",
        },
    },
    .{
        .name = "while",
        .kind = .control_flow,
        .profile = .min,
        .description = "Conditional loop",
        .examples = &[_][]const u8{
            "while condition do update() end",
            "while !queue.empty() do process(queue.pop()) end",
        },
    },
    .{
        .name = "match",
        .kind = .control_flow,
        .profile = .min,
        .description = "Pattern matching statement",
        .examples = &[_][]const u8{
            "match value do\n  0 => \"zero\"\n  n when n > 0 => \"positive\"\n  _ => \"negative\"\nend",
        },
    },

    // NEW: when keyword - Universal conditional guard
    .{
        .name = "when",
        .kind = .control_flow,
        .profile = .min,
        .description = "Conditional guard for match statements and postfix conditionals",
        .examples = &[_][]const u8{
            // Match guards
            "match x do\n  n when n < 10 => \"small\"\n  n when n > 100 => \"large\"\n  _ => \"medium\"\nend",
            // Postfix conditionals
            "return Error.InvalidInput when user == null",
            "log.warn(\"Inactive user\") when user.is_inactive",
            "break when found",
        },
    },

    .{
        .name = "return",
        .kind = .control_flow,
        .profile = .min,
        .description = "Function return statement",
        .examples = &[_][]const u8{
            "return result",
            "return Error.InvalidInput when input == null",
        },
    },
    .{
        .name = "break",
        .kind = .control_flow,
        .profile = .min,
        .description = "Loop exit statement",
        .examples = &[_][]const u8{
            "break",
            "break when condition",
        },
    },
    .{
        .name = "continue",
        .kind = .control_flow,
        .profile = .min,
        .description = "Loop continue statement",
        .examples = &[_][]const u8{
            "continue",
            "continue when should_skip",
        },
    },

    // Block delimiters
    .{
        .name = "do",
        .kind = .block_delimiter,
        .profile = .min,
        .description = "Block start delimiter",
        .examples = &[_][]const u8{
            "if condition do ... end",
            "for item in items do ... end",
        },
    },
    .{
        .name = "end",
        .kind = .block_delimiter,
        .profile = .min,
        .description = "Block end delimiter",
        .examples = &[_][]const u8{
            "if condition do ... end",
            "match value do ... end",
        },
    },

    // Capability keywords (:go profile)
    .{
        .name = "cap",
        .kind = .capability,
        .profile = .go,
        .description = "Capability declaration",
        .examples = &[_][]const u8{
            "cap fs.read",
            "cap net.http + fs.write",
        },
    },
    .{
        .name = "with",
        .kind = .capability,
        .profile = .go,
        .description = "Capability context",
        .examples = &[_][]const u8{
            "with cap.fs.read do ... end",
            "with cap.net.http + cap.fs.write do ... end",
        },
    },
    .{
        .name = "using",
        .kind = .capability,
        .profile = .go,
        .description = "Resource management",
        .examples = &[_][]const u8{
            "using file = fs.open(\"data.txt\") do ... end",
            "using connection = db.connect() do ... end",
        },
    },

    // Actor keywords (:elixir profile)
    .{
        .name = "actor",
        .kind = .concurrency,
        .profile = .elixir,
        .description = "Actor declaration",
        .examples = &[_][]const u8{
            "actor Counter { ... }",
            "actor FileManager { state files = {} ... }",
        },
    },
    .{
        .name = "spawn",
        .kind = .concurrency,
        .profile = .elixir,
        .description = "Actor spawning",
        .examples = &[_][]const u8{
            "spawn Counter.new()",
            "spawn FileManager.new() when needed",
        },
    },

    // Metaprogramming keywords (:full profile)
    .{
        .name = "comptime",
        .kind = .metaprogramming,
        .profile = .full,
        .description = "Compile-time execution",
        .examples = &[_][]const u8{
            "comptime { validate_config() }",
            "comptime let version = get_build_version()",
        },
    },

    // Reserved for post-1.0
    .{
        .name = "yield",
        .kind = .concurrency,
        .profile = .post_1_0,
        .description = "Coroutine suspension point (POST-1.0)",
        .examples = &[_][]const u8{
            "yield  // Explicit suspension",
            "yield when should_pause",
        },
    },
};

/// LSP keyword completion provider
pub const KeywordCompletionProvider = struct {
    allocator: Allocator,
    current_profile: JanusKeyword.LanguageProfile,

    pub fn init(allocator: Allocator, profile: JanusKeyword.LanguageProfile) KeywordCompletionProvider {
        return KeywordCompletionProvider{
            .allocator = allocator,
            .current_profile = profile,
        };
    }

    /// Get available keywords for current profile
    pub fn getAvailableKeywords(self: *KeywordCompletionProvider) []const JanusKeyword {
        var available = ArrayList(JanusKeyword).init(self.allocator);

        for (JANUS_KEYWORDS) |keyword| {
            if (self.isKeywordAvailable(keyword)) {
                available.append(keyword) catch continue;
            }
        }

        return try available.toOwnedSlice(alloc) catch &[_]JanusKeyword{};
    }

    /// Check if keyword is available in current profile
    fn isKeywordAvailable(self: *KeywordCompletionProvider, keyword: JanusKeyword) bool {
        const profile_level = @intFromEnum(self.current_profile);
        const keyword_level = @intFromEnum(keyword.profile);
        return keyword_level <= profile_level;
    }

    /// Get keyword by name
    pub fn getKeyword(name: []const u8) ?JanusKeyword {
        for (JANUS_KEYWORDS) |keyword| {
            if (std.mem.eql(u8, keyword.name, name)) {
                return keyword;
            }
        }
        return null;
    }

    /// Generate completion items for LSP
    pub fn generateCompletionItems(self: *KeywordCompletionProvider) ![]CompletionItem {
        const available = self.getAvailableKeywords();
        var items = ArrayList(CompletionItem).init(self.allocator);

        for (available) |keyword| {
            const item = CompletionItem{
                .label = keyword.name,
                .kind = self.keywordKindToCompletionKind(keyword.kind),
                .detail = keyword.description,
                .documentation = try self.formatKeywordDocumentation(keyword),
                .insert_text = try self.generateInsertText(keyword),
            };
            try items.append(item);
        }

        return try items.toOwnedSlice(alloc);
    }

    fn keywordKindToCompletionKind(self: *KeywordCompletionProvider, kind: JanusKeyword.KeywordKind) CompletionItemKind {
        _ = self;
        return switch (kind) {
            .control_flow => .Keyword,
            .declaration => .Keyword,
            .block_delimiter => .Keyword,
            .capability => .Keyword,
            .concurrency => .Keyword,
            .metaprogramming => .Keyword,
        };
    }

    fn formatKeywordDocumentation(self: *KeywordCompletionProvider, keyword: JanusKeyword) ![]const u8 {
        var doc = ArrayList(u8).init(self.allocator);
        const writer = doc.writer();

        try writer.print("**{}** - {}\n\n", .{ keyword.name, keyword.description });
        try writer.print("**Profile:** {s}\n\n", .{ @tagName(keyword.profile) });

        if (keyword.examples.len > 0) {
            try writer.print("**Examples:**\n");
            for (keyword.examples) |example| {
                try writer.print("```janus\n{s}\n```\n", .{example});
            }
        }

        // Special documentation for when keyword
        if (std.mem.eql(u8, keyword.name, "when")) {
            try writer.print("\n**Usage Patterns:**\n");
            try writer.print("- **Match Guards:** `n when n < 10 => \"small\"`\n");
            try writer.print("- **Postfix Conditionals:** `return error when condition`\n");
            try writer.print("- **Honest Sugar:** Desugars to `if condition do statement end`\n");
        }

        return try doc.toOwnedSlice(alloc);
    }

    fn generateInsertText(self: *KeywordCompletionProvider, keyword: JanusKeyword) ![]const u8 {
        _ = self;

        // Special insert text for keywords that commonly need additional syntax
        if (std.mem.eql(u8, keyword.name, "if")) {
            return try self.allocator.dupe(u8, "if ${1:condition} do\n\t${2:body}\nend");
        } else if (std.mem.eql(u8, keyword.name, "for")) {
            return try self.allocator.dupe(u8, "for ${1:item} in ${2:collection} do\n\t${3:body}\nend");
        } else if (std.mem.eql(u8, keyword.name, "match")) {
            return try self.allocator.dupe(u8, "match ${1:value} do\n\t${2:pattern} => ${3:result}\nend");
        } else if (std.mem.eql(u8, keyword.name, "when")) {
            return try self.allocator.dupe(u8, "when ${1:condition}");
        } else if (std.mem.eql(u8, keyword.name, "func")) {
            return try self.allocator.dupe(u8, "func ${1:name}(${2:params}) -> ${3:return_type} {\n\t${4:body}\n}");
        }

        return try self.allocator.dupe(u8, keyword.name);
    }
};

/// LSP completion item structure
pub const CompletionItem = struct {
    label: []const u8,
    kind: CompletionItemKind,
    detail: []const u8,
    documentation: []const u8,
    insert_text: []const u8,
};

pub const CompletionItemKind = enum {
    Text,
    Method,
    Function,
    Constructor,
    Field,
    Variable,
    Class,
    Interface,
    Module,
    Property,
    Unit,
    Value,
    Enum,
    Keyword,
    Snippet,
    Color,
    File,
    Reference,
};

/// Syntax highlighting support for when keyword
pub const SyntaxHighlighting = struct {
    /// Get token type for syntax highlighting
    pub fn getTokenType(token: []const u8) TokenType {
        if (getKeyword(token)) |keyword| {
            return switch (keyword.kind) {
                .control_flow => .ControlKeyword,
                .declaration => .DeclarationKeyword,
                .block_delimiter => .BlockDelimiter,
                .capability => .CapabilityKeyword,
                .concurrency => .ConcurrencyKeyword,
                .metaprogramming => .MetaprogrammingKeyword,
            };
        }
        return .Identifier;
    }

    pub const TokenType = enum {
        Identifier,
        ControlKeyword,
        DeclarationKeyword,
        BlockDelimiter,
        CapabilityKeyword,
        ConcurrencyKeyword,
        MetaprogrammingKeyword,
        String,
        Number,
        Comment,
        Operator,
    };
};

// Comprehensive test suite
test "keyword availability by profile" {
    const allocator = std.testing.allocator;

    // Test :min profile
    var min_provider = KeywordCompletionProvider.init(allocator, .min);
    const min_keywords = min_provider.getAvailableKeywords();
    defer allocator.free(min_keywords);

    // Should include when keyword
    var has_when = false;
    var has_actor = false;

    for (min_keywords) |keyword| {
        if (std.mem.eql(u8, keyword.name, "when")) has_when = true;
        if (std.mem.eql(u8, keyword.name, "actor")) has_actor = true;
    }

    try std.testing.expect(has_when); // when should be in :min
    try std.testing.expect(!has_actor); // actor should not be in :min
}

test "when keyword documentation" {
    const when_keyword = getKeyword("when");
    try std.testing.expect(when_keyword != null);
    try std.testing.expect(when_keyword.?.profile == .min);
    try std.testing.expect(when_keyword.?.examples.len >= 2);
}

test "syntax highlighting for when keyword" {
    const token_type = SyntaxHighlighting.getTokenType("when");
    try std.testing.expect(token_type == .ControlKeyword);
}
