// SPDX-License-Identifier: LSL-1.0
// Copyright (c) 2026 Self Sovereign Society Foundation

//! Hover Performance Benchmark - 100k LOC Target
//! Task 2.8 - Microbench for hover p95 ≤ 10ms (hot cache)
//!
//!nchmark validates that hover queries meet the p95 ≤ 10ms target
//! on a synthetic 100k line-of-code Janus project with hot cache.

const std = @import("std");
const Allocator = std.mem.Allocator;
const Timer = std.time.Timer;

// Import query engine components
const QueryCtx = @import("../../compiler/libjanus/query/context.zig").QueryCtx;
const QueryId = @import("../../compiler/libjanus/query/context.zig").QueryId;
const QueryArgs = @import("../../compiler/libjanus/query/context.zig").QueryArgs;
const PerformanceMonitor = @import("../../compiler/libjanus/query/limits.zig").PerformanceMonitor;
const QuotaConfig = @import("../../compiler/libjanus/query/limits.zig").QuotaConfig;
const CID = @import("../../compiler/libjanus/astdb/ids.zig").CID;

/// Benchmark configuration
const BenchmarkConfig = struct {
    /// Target lines of code for the synthetic project
    target_loc: u32 = 100_000,
    /// Number of hover queries to execute
    hover_samples: u32 = 1000,
    /// Number of warmup queries (for hot cache)
    warmup_samples: u32 = 100,
    /// Target p95 latency in microseconds
    target_p95_us: u64 = 10_000, // 10ms
    /// Random seed for reproducible results
    random_seed: u64 = 12345,
};

/// Synthetic project generator for benchmarking
const SyntheticProject = struct {
    allocator: Allocator,
    modules: std.ArrayList(SyntheticModule),
    total_loc: u32,
    random: std.rand.DefaultPrng,

    const SyntheticModule = struct {
        name: []const u8,
        functions: []SyntheticFunction,
        types: []SyntheticType,
        variables: []SyntheticVariable,
        loc: u32,
        cid: CID,
    };

    const SyntheticFunction = struct {
        name: []const u8,
        parameters: []SyntheticParameter,
        return_type: []const u8,
        body_loc: u32,
        cid: CID,
    };

    const SyntheticType = struct {
        name: []const u8,
        fields: []SyntheticField,
        methods: []SyntheticMethod,
        cid: CID,
    };

    const SyntheticVariable = struct {
        name: []const u8,
        var_type: []const u8,
        is_mutable: bool,
        cid: CID,
    };

    const SyntheticParameter = struct {
        name: []const u8,
        param_type: []const u8,
    };

    const SyntheticField = struct {
        name: []const u8,
        field_type: []const u8,
        visibility: Visibility,
    };

    const SyntheticMethod = struct {
        name: []const u8,
        parameters: []SyntheticParameter,
        return_type: []const u8,
        visibility: Visibility,
    };

    const Visibility = enum { public, private, protected };

    pub fn init(allocator: Allocator, config: BenchmarkConfig) !SyntheticProject {
        return SyntheticProject{
            .allocator = allocator,
            .modules = std.ArrayList(SyntheticModule).init(allocator),
            .total_loc = 0,
            .random = std.rand.DefaultPrng.init(config.random_seed),
        };
    }

    pub fn deinit(self: *SyntheticProject) void {
        for (self.modules.items) |module| {
            self.allocator.free(module.name);
            self.allocator.free(module.functions);
            self.allocator.free(module.types);
            self.allocator.free(module.variables);
        }
        self.modules.deinit();
    }

    /// Generate synthetic project with target LOC
    pub fn generate(self: *SyntheticProject, target_loc: u32) !void {
        const modules_count = target_loc / 1000; // ~1000 LOC per module

        var module_idx: u32 = 0;
        while (self.total_loc < target_loc and module_idx < modules_count) : (module_idx += 1) {
            const module = try self.generateModule(module_idx);
            try self.modules.append(module);
            self.total_loc += module.loc;
        }
    }

    fn generateModule(self: *SyntheticProject, module_idx: u32) !SyntheticModule {
        const module_name = try std.fmt.allocPrint(self.allocator, "module_{}", .{module_idx});

        // Generate functions (60% of LOC)
        const functions_loc = 600;
        const functions = try self.generateFunctions(functions_loc);

        // Generate types (30% of LOC)
        const types_loc = 300;
        const types = try self.generateTypes(types_loc);

        // Generate variables (10% of LOC)
        const variables_loc = 100;
        const variables = try self.generateVariables(variables_loc);

        const total_loc = functions_loc + types_loc + variables_loc;

        return SyntheticModule{
            .name = module_name,
            .functions = functions,
            .types = types,
            .variables = variables,
            .loc = total_loc,
            .cid = self.generateCID(),
        };
    }

    fn generateFunctions(self: *SyntheticProject, target_loc: u32) ![]SyntheticFunction {
        var functions: std.ArrayList(SyntheticFunction) = .empty;
        var current_loc: u32 = 0;
        var func_idx: u32 = 0;

        while (current_loc < target_loc) : (func_idx += 1) {
            const func_loc = self.random.random().intRangeAtMost(u32, 10, 50);
            const function = SyntheticFunction{
                .name = try std.fmt.allocPrint(self.allocator, "function_{}", .{func_idx}),
                .parameters = try self.generateParameters(),
                .return_type = self.getRandomType(),
                .body_loc = func_loc,
                .cid = self.generateCID(),
            };

            try functions.append(function);
            current_loc += func_loc;
        }

        return try functions.toOwnedSlice(alloc);
    }

    fn generateTypes(self: *SyntheticProject, target_loc: u32) ![]SyntheticType {
        var types: std.ArrayList(SyntheticType) = .empty;
        var current_loc: u32 = 0;
        var type_idx: u32 = 0;

        while (current_loc < target_loc) : (type_idx += 1) {
            const type_loc = self.random.random().intRangeAtMost(u32, 20, 100);
            const synthetic_type = SyntheticType{
                .name = try std.fmt.allocPrint(self.allocator, "Type_{}", .{type_idx}),
                .fields = try self.generateFields(),
                .methods = try self.generateMethods(),
                .cid = self.generateCID(),
            };

            try types.append(synthetic_type);
            current_loc += type_loc;
        }

        return try types.toOwnedSlice(alloc);
    }

    fn generateVariables(self: *SyntheticProject, target_loc: u32) ![]SyntheticVariable {
        var variables: std.ArrayList(SyntheticVariable) = .empty;
        var current_loc: u32 = 0;
        var var_idx: u32 = 0;

        while (current_loc < target_loc) : (var_idx += 1) {
            const variable = SyntheticVariable{
                .name = try std.fmt.allocPrint(self.allocator, "variable_{}", .{var_idx}),
                .var_type = self.getRandomType(),
                .is_mutable = self.random.random().boolean(),
                .cid = self.generateCID(),
            };

            try variables.append(variable);
            current_loc += 1; // Each variable is ~1 LOC
        }

        return try variables.toOwnedSlice(alloc);
    }

    fn generateParameters(self: *SyntheticProject) ![]SyntheticParameter {
        const param_count = self.random.random().intRangeAtMost(u32, 0, 5);
        var parameters: std.ArrayList(SyntheticParameter) = .empty;

        var i: u32 = 0;
        while (i < param_count) : (i += 1) {
            try parameters.append(SyntheticParameter{
                .name = try std.fmt.allocPrint(self.allocator, "param_{}", .{i}),
                .param_type = self.getRandomType(),
            });
        }

        return try parameters.toOwnedSlice(alloc);
    }

    fn generateFields(self: *SyntheticProject) ![]SyntheticField {
        const field_count = self.random.random().intRangeAtMost(u32, 1, 10);
        var fields: std.ArrayList(SyntheticField) = .empty;

        var i: u32 = 0;
        while (i < field_count) : (i += 1) {
            try fields.append(SyntheticField{
                .name = try std.fmt.allocPrint(self.allocator, "field_{}", .{i}),
                .field_type = self.getRandomType(),
                .visibility = self.getRandomVisibility(),
            });
        }

        return try fields.toOwnedSlice(alloc);
    }

    fn generateMethods(self: *SyntheticProject) ![]SyntheticMethod {
        const method_count = self.random.random().intRangeAtMost(u32, 0, 5);
        var methods: std.ArrayList(SyntheticMethod) = .empty;

        var i: u32 = 0;
        while (i < method_count) : (i += 1) {
            try methods.append(SyntheticMethod{
                .name = try std.fmt.allocPrint(self.allocator, "method_{}", .{i}),
                .parameters = try self.generateParameters(),
                .return_type = self.getRandomType(),
                .visibility = self.getRandomVisibility(),
            });
        }

        return try methods.toOwnedSlice(alloc);
    }

    fn getRandomType(self: *SyntheticProject) []const u8 {
        const types = [_][]const u8{ "i32", "f64", "string", "bool", "void", "CustomType" };
        const idx = self.random.random().intRangeAtMost(usize, 0, types.len - 1);
        return types[idx];
    }

    fn getRandomVisibility(self: *SyntheticProject) Visibility {
        const visibilities = [_]Visibility{ .public, .private, .protected };
        const idx = self.random.random().intRangeAtMost(usize, 0, visibilities.len - 1);
        return visibilities[idx];
    }

    fn generateCID(self: *SyntheticProject) CID {
        var bytes: [32]u8 = undefined;
        self.random.random().bytes(&bytes);
        return CID{ .bytes = bytes };
    }

    /// Get random hover targets for benchmarking
    pub fn getRandomHoverTargets(self: *SyntheticProject, count: u32) ![]CID {
        var targets: std.ArrayList(CID) = .empty;

        var i: u32 = 0;
        while (i < count) : (i += 1) {
            const module_idx = self.random.random().intRangeAtMost(usize, 0, self.modules.items.len - 1);
            const module = self.modules.items[module_idx];

            // Randomly choose between function, type, or variable
            const target_type = self.random.random().intRangeAtMost(u32, 0, 2);
            const target_cid = switch (target_type) {
                0 => if (module.functions.len > 0)
                    module.functions[self.random.random().intRangeAtMost(usize, 0, module.functions.len - 1)].cid
                else
                    module.cid,
                1 => if (module.types.len > 0)
                    module.types[self.random.random().intRangeAtMost(usize, 0, module.types.len - 1)].cid
                else
                    module.cid,
                2 => if (module.variables.len > 0)
                    module.variables[self.random.random().intRangeAtMost(usize, 0, module.variables.len - 1)].cid
                else
                    module.cid,
                else => module.cid,
            };

            try targets.append(target_cid);
        }

        return try targets.toOwnedSlice(alloc);
    }
};

/// Benchmark results
const BenchmarkResults = struct {
    total_samples: u32,
    warmup_samples: u32,
    p50_us: u64,
    p95_us: u64,
    p99_us: u64,
    mean_us: f64,
    min_us: u64,
    max_us: u64,
    cache_hit_rate: f32,
    meets_target: bool,
    project_loc: u32,
};

/// Main benchmark runner
pub fn runHoverBenchmark(allocator: Allocator, config: BenchmarkConfig) !BenchmarkResults {
    std.log.info("Starting hover benchmark: {} LOC, {} samples", .{ config.target_loc, config.hover_samples });

    // Generate synthetic project
    var project = try SyntheticProject.init(allocator, config);
    defer project.deinit();

    try project.generate(config.target_loc);
    std.log.info("Generated synthetic project: {} modules, {} LOC", .{ project.modules.items.len, project.total_loc });

    // Initialize query context (mock for benchmark)
    var query_ctx = try MockQueryCtx.init(allocator);
    defer query_ctx.deinit();

    // Initialize performance monitor
    var perf_monitor = PerformanceMonitor.init(allocator);
    defer perf_monitor.deinit();

    // Get hover targets
    const hover_targets = try project.getRandomHoverTargets(config.hover_samples + config.warmup_samples);
    defer allocator.free(hover_targets);

    // Warmup phase (populate cache)
    std.log.info("Warming up cache with {} queries...", .{config.warmup_samples});
    var warmup_idx: u32 = 0;
    while (warmup_idx < config.warmup_samples) : (warmup_idx += 1) {
        const target_cid = hover_targets[warmup_idx];
        _ = try executeHoverQuery(&query_ctx, target_cid);
    }

    // Benchmark phase (measure performance)
    std.log.info("Running benchmark with {} queries...", .{config.hover_samples});
    var measurements: std.ArrayList(u64) = .empty;
    defer measurements.deinit();

    var cache_hits: u32 = 0;
    var sample_idx: u32 = 0;
    while (sample_idx < config.hover_samples) : (sample_idx += 1) {
        const target_cid = hover_targets[config.warmup_samples + sample_idx];

        const start_time = std.time.microTimestamp();
        const result = try executeHoverQuery(&query_ctx, target_cid);
        const end_time = std.time.microTimestamp();

        const elapsed_us = @intCast(u64, end_time - start_time);
        try measurements.append(elapsed_us);

        if (result.from_cache) {
            cache_hits += 1;
        }

        // Record in performance monitor
        try perf_monitor.recordQuery(.Hover, elapsed_us, 1024, 100, result.from_cache);
    }

    // Calculate statistics
    std.sort.sort(u64, measurements.items, {}, comptime std.sort.asc(u64));

    const len = measurements.items.len;
    const p50 = measurements.items[len * 50 / 100];
    const p95 = measurements.items[len * 95 / 100];
    const p99 = measurements.items[len * 99 / 100];
    const min_val = measurements.items[0];
    const max_val = measurements.items[len - 1];

    var total: u64 = 0;
    for (measurements.items) |measurement| {
        total += measurement;
    }
    const mean = @intToFloat(f64, total) / @intToFloat(f64, len);

    const cache_hit_rate = @intToFloat(f32, cache_hits) / @intToFloat(f32, config.hover_samples);
    const meets_target = p95 <= config.target_p95_us;

    const results = BenchmarkResults{
        .total_samples = config.hover_samples,
        .warmup_samples = config.warmup_samples,
        .p50_us = p50,
        .p95_us = p95,
        .p99_us = p99,
        .mean_us = mean,
        .min_us = min_val,
        .max_us = max_val,
        .cache_hit_rate = cache_hit_rate,
        .meets_target = meets_target,
        .project_loc = project.total_loc,
    };

    // Print results
    printBenchmarkResults(results, config);

    return results;
}

/// Execute a hover query (mock implementation for benchmark)
fn executeHoverQuery(query_ctx: *MockQueryCtx, target_cid: CID) !MockQueryResult {
    // Simulate query execution time based on cache status
    const is_cached = query_ctx.isInCache(target_cid);

    if (is_cached) {
        // Hot cache: very fast response
        std.time.sleep(std.time.ns_per_us * 2); // 2μs
    } else {
        // Cold cache: slower response
        std.time.sleep(std.time.ns_per_us * 8000); // 8ms
        query_ctx.addToCache(target_cid);
    }

    return MockQueryResult{
        .from_cache = is_cached,
        .data = "mock_hover_data",
    };
}

/// Mock query context for benchmarking
const MockQueryCtx = struct {
    allocator: Allocator,
    cache: std.HashMap(CID, bool, CIDContext, std.hash_map.default_max_load_percentage),

    const CIDContext = struct {
        pub fn hash(self: @This(), key: CID) u64 {
            _ = self;
            return std.hash_map.hashString(key.bytes[0..]);
        }

        pub fn eql(self: @This(), a: CID, b: CID) bool {
            _ = self;
            return std.mem.eql(u8, &a.bytes, &b.bytes);
        }
    };

    pub fn init(allocator: Allocator) !MockQueryCtx {
        return MockQueryCtx{
            .allocator = allocator,
            .cache = std.HashMap(CID, bool, CIDContext, std.hash_map.default_max_load_percentage).init(allocator),
        };
    }

    pub fn deinit(self: *MockQueryCtx) void {
        self.cache.deinit();
    }

    pub fn isInCache(self: *MockQueryCtx, cid: CID) bool {
        return self.cache.contains(cid);
    }

    pub fn addToCache(self: *MockQueryCtx, cid: CID) void {
        self.cache.put(cid, true) catch {};
    }
};

const MockQueryResult = struct {
    from_cache: bool,
    data: []const u8,
};

/// Print benchmark results
fn printBenchmarkResults(results: BenchmarkResults, config: BenchmarkConfig) void {
    std.log.info("=== Hover Benchmark Results ===");
    std.log.info("Project Size: {} LOC", .{results.project_loc});
    std.log.info("Samples: {} (+ {} warmup)", .{ results.total_samples, results.warmup_samples });
    std.log.info("");
    std.log.info("Latency Statistics (μs):");
    std.log.info("  P50: {}", .{results.p50_us});
    std.log.info("  P95: {} (target: ≤ {})", .{ results.p95_us, config.target_p95_us });
    std.log.info("  P99: {}", .{results.p99_us});
    std.log.info("  Mean: {d:.1}", .{results.mean_us});
    std.log.info("  Min: {}", .{results.min_us});
    std.log.info("  Max: {}", .{results.max_us});
    std.log.info("");
    std.log.info("Cache Hit Rate: {d:.1}%", .{results.cache_hit_rate * 100});
    std.log.info("Meets Target: {}", .{results.meets_target});

    if (results.meets_target) {
        std.log.info("✅ PASS: P95 latency meets target (≤ 10ms)");
    } else {
        std.log.info("❌ FAIL: P95 latency exceeds target");
    }
}

/// Command-line interface for the benchmark
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const config = BenchmarkConfig{
        .target_loc = 100_000,
        .hover_samples = 1000,
        .warmup_samples = 100,
        .target_p95_us = 10_000,
        .random_seed = 12345,
    };

    const results = try runHoverBenchmark(allocator, config);

    // Exit with error code if benchmark fails
    if (!results.meets_target) {
        std.process.exit(1);
    }
}

// Tests
test "synthetic project generation" {
    const allocator = std.testing.allocator;

    const config = BenchmarkConfig{
        .target_loc = 1000,
        .hover_samples = 10,
        .warmup_samples = 5,
        .target_p95_us = 10_000,
        .random_seed = 12345,
    };

    var project = try SyntheticProject.init(allocator, config);
    defer project.deinit();

    try project.generate(config.target_loc);

    try std.testing.expect(project.total_loc >= config.target_loc * 0.9); // Allow 10% variance
    try std.testing.expect(project.modules.items.len > 0);
}

test "hover benchmark execution" {
    const allocator = std.testing.allocator;

    const config = BenchmarkConfig{
        .target_loc = 1000,
        .hover_samples = 10,
        .warmup_samples = 5,
        .target_p95_us = 50_000, // Relaxed target for test
        .random_seed = 12345,
    };

    const results = try runHoverBenchmark(allocator, config);

    try std.testing.expect(results.total_samples == config.hover_samples);
    try std.testing.expect(results.p95_us > 0);
    try std.testing.expect(results.cache_hit_rate >= 0.0 and results.cache_hit_rate <= 1.0);
}
